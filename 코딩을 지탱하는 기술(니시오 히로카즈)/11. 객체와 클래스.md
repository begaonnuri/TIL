## 객체 지향이란?

C++의 설계자인 Bjarne Stroustrup은 'class는 사용자 정의형을 만드기 위한 구조'라고 설명한다. 또한 'Simula의 상속 구조가 문제 해결의 키다', '객체지향 프로그래밍이란 사용자 정의형과 상속을 사용한 프로그래밍이다'라고 설명하고 있다.

하지만 객체지향이란 용어의 발명자인 Alan Kay는 다른 의견을 갖고있다. '형에는 반대하지 않지만 고생하지 않는 형 시스템을 본 적이 없다', 'Simula의 상속 방법은 좋지 않다', '객체 지향이란 상태를 가진 객체가 메시지를 주고 받아서 커뮤니케이션 하는 프로그램이다'라고 주장하며, 형이나 상속에 대한 부정적인 입장을 취하고 있다.



### 객체는 현실 세계의 모형

우리들은 자신이 경험한 것을 사물이라는 개념으로 정리해두고 있다. 그리고 우리의 사고, 행동은 사물을 가리키거나 설명하거나 조작하기 위해 만들어졌다. 우리가 컴퓨터로 문제를 해결할 때 현실 세계의 사물 모형을 컴퓨터 안에 만들 필요가 있다. 그렇게 객체 지향이 탄생했다.



### 클래스란?

C++에선 클래스는 사용자가 정의할 수 있는 형이라고 한다. 하지만 Ruby와 Python에선 형이란 용어가 가리키는 것이 C++과 다르기 때문에 클래스가 가리키는 것도 다르다.

대부분의 언어에서 클래스는 필수 조건이 아니지만 Java에선 클래스라는 부품을 정의하고 그것을 조립해나가는 것이 프로그래밍이라고 말하기 때문에 필수 조건이다.

작은 규모의 프로그램이라면 굳이 클래스를 만들지 않아도 된다. 대규모 프로그램을 많은 사람이 나눠서 작업하는 경우나 GUI를 만드는 경우엔 객체 지향이 좋다. 필요한 것들을 하나의 클래스로 묶어서 표현하면 프로그램을 만들기도 읽기도 쉬워진다.



## 변수와 함수를 합쳐서 모형을 만드는 법

하나로 모으기 위한 방법은 여러 가지가 있다. C++, Java의 클래스가 대표적이지만 이외에도 여러 방법이 있다.

첫 번째는 모듈이다. 관련된 함수를 하나로 모으기 위한 기능이었다. Perl에서는 비슷한 기능을 패키지라고 부른다. Perl은 객체 지향을 도입하기 위해 함수를 합쳐두기 위한 패키지와 변수를 합쳐두기 위한 해쉬를 연결하는 방식을 채택했다.

두 번째는 함수와 변수를 동일하게 해쉬에 넣는 방법이다. JavaScript에선 이 방법을 채용하고 있다.

세 번째는 클로저(Closure)로 함수 실행 시 이름 공간의 변수를 하나로 묶기 위해 사용하는 방법이다. 주로 함수형 언어에서 사용된다.



## 방법 1: 모듈, 패키지

### 모듈, 패키지란 무엇인가?

하나의 프로그램 안에는 여러 구성 요소가 상호작용을 하고있다. 프로그램을 설계하다 보면 상호간의 연결성이 강한 그룹이 생기는데, 이 그룹을 묶어서 나누는 것이 이해하기 쉽다. Python과 Ruby에서는 모듈이라고 하고, Java와 Perl에서는 패키지라는 이름으로 부른다.



### Perl 패키지로 객체를 만든다

Perl 패키지는 함수나 변수를 하나로 묶어서 그것에 이름을 붙이는 기능이다.

```perl
{
	package Counter;
	my $count = 0;
	my $name = "참새";
	
	sub push{
		$count++;
		print "$name: $count마리 \n";
	}
}
```



### 모듈만으로는 부족하다

함수나 모듈은 하나의 정의에 하나의 실체가 대응하고 있다. 하지만 현실에서는 비슷한 사물이 복수개 있는 상황이 존재한다. 예를 들어 참새와 까마귀가 각각 몇 마리인지 세고 싶다고 할 때 또 다른 카운터 패키지가 필요하다.



### 별도의 데이터 저장소를 만든다

버튼을 눌렀을 때 수치를 증가시키는 기능은 카운터A와 카운터B에 공통적으로 있는 동작이니 하나만 있어도 된다.

하지만 카운터 수치는 카운터A와 카운터B가 별개라서 각각 있어야 한다. 즉, 데이터를 저장하는 장소만 개별적으로 여러 개 만드는 방법이 있으면 된다.



### 인수로 개별 해쉬를 전달한다

Perl에는 사전이라는 해쉬가 내장되어 있다. 해쉬 함수를 호출할 때 해쉬를 인수로 전달한다.

```perl
{
	package Counter;
	sub push{
		my $values = shift;
		$values -> {count}++;
		print "$values->{count}마리 \n";
	}
}
{
	my $counter = {"value" => 0};
	my $counter2 = {"value" => 0};
	Counter::push($counter);
	Counter::push($counter2);
}
```

이 경우 $counter와 $counter2가 각각 다른 객체이기 때문에 개별적으로 증가한다.



### 초기화 처리도 패키지에 넣는다

위 코드에선 새로운 카운터를 만들 때 마다 `{"value" => 0}`라고 써줘야 한다. 값을 어떻게 초기화할지 사람이 기억해야만 하는 것이다. 이것은 좋지 않은 설계다. 초기화 방법을 함수로 만들어서 패키지에 넣어서 해결한다.

```perl
{
	package Counter;
	sub new{
		return {"value" => 0};
	}
	sub push{
		my $values = shift;
		$values -> {count}++;
		print "$values->{count}마리 \n";
	}
}
{
	my $counter = Counter::new;
	Counter::push($counter);
}
```

여기서 new와 같이 객체를 만드는 함수를 생성자(constructor)라고 부른다.



### 해쉬와 패키지를 연결한다

생성자로 해결은 했지만 Counter::push($counter)에 중복이 존재한다. 해시가 Counter패키지와 세트로 사용하기 위한 것이라는 정보를 기억하게 하는 것이 필요했다. 이를 위해 Perl에서 bless라는 개념이 나왔다. Perl은 해쉬와 패키지명을 연결해 bless된 해쉬를 만든다.

```perl
{
	my $counter = {counter => 0};
	bless $counter, "Counter";
	$counter->push;
}
```

bless된 해쉬에서 `->`를 사용해 패키지 안의 함수를 호출할 수 있다.

이렇게 카운터를 하나의 객체로 만들 수 있었다.



## 방법 2: 함수도 해쉬에 넣는다

Perl에서는 패키지를 사용해 복수의 함수를 묶어서 사용할 수 있었다. 다음은 JavaScript가 사용하고 있는 함수도 해쉬에 넣는 접근법이다.

대부분의 언어에선 문자열을 변수에 대입할 수 있다. 하지만 모든 언어가 가능한 것은 아니다. FORTRAN 66에서는 문자열을 변수에 대입할 수 없다.

이와 같이 제한 없이 변수에 대입하고, 함수의 인자로 전달하고, 함수의 반환값으로 전달이 가능한 값을 **퍼스트 클래스(first class)** 값이라고 한다. 차별 대상이 아닌 **일급 시민(first-class citizen)**을 의미하는 표현이다. Java, Perl, Python같은 최근의 언어에서 문자열은 퍼스트 클래스 값이다.

JavaScript에서는 함수도 퍼스트 클래스 값이다. 이런 특징을 통해 다음과 같은 활용이 가능하다.



### 함수를 해쉬에 넣는다

JavaScript 해쉬는 다음과 같다

```javascript
{count: 0, name: "참새"}
```

여기서 값의 부분에 함수를 넣을 수도 있다.

```javascript
var counter = {
    count: 0,
    name: "참새",
    push: function() {
        this.count++;
        console.log(this.name + ": " + this.count + "마리");
    }
}
```

Perl에선 패키지였던 것이 JavaScript에선 해쉬로 되어있다. 또 다른 차이점은 this가 존재한다. this는 예약어로 함수 안에서 객체를 참조하기 위해 사용한다. Perl에선 명시적으로 shift를 통해 인수를 꺼냈지만 JavaScript에선 암묵적으로 this라는 이름의 함수에 들어간다.

여기서도 패키지와 동일하게 하나의 카운터만 만들 수 있다는 문제가 있다.



### 복수 개의 카운터를 만든다

카운터를 복수 개 만들기 위해선 해쉬를 작성하는 코드를 함수 안으로 이동하기만 하면 된다.

```javascript
function makeCounter(){
    return {
        count: 0,
        push: function() {
            this.count++;
            console.log(this.name + ": " + this.count + "마리");
        }
    }
}

var c1 = makeCounter();
var c2 = makeCounter();
```

이렇게 할 경우 Perl 패키지와 동일하게 다음과 같은 이점을 갖게 된다.

- 복수의 객체를 만들 수 있다.
- 하나의 묶음으로 보인다.
- 초기화 방법을 사람이 기억하지 않아도 된다.



### 공유하고 있는 사물을 프로토타입으로 이동한다

앞의 코드는 push 함수가 매번 새롭게 생성된다. JavaScript는 이 문제를 프로토타입(Prototype)이라는 개념을 통해 해결한다.

어떤 객체에 x의 값에 대해 물어봤을 때 자신이 알고 있으면 알려주고 그렇지 않으면 자신의 프로토타입에 물어서 답한다.



프로토타입을 사용한 처리를 편하기 하기 위한 new 연산자도 있다.

```javascript
var Counter = function() {
    this.count = 0;
}

Counter.prototype.push = function() {
    this.count++;
    console.log(this.count + "마리");
}

var c1 = new Counter();
```

new를 호출하면 다음과 같은 처리가 이루어진다.

- 새로운 객체를 만든다.
- 만들어진 객체 프로토타입을 함수 x의 프로토타입으로 변경한다.
- 만들어진 객체를 this에 넣어서 함수 x의 본체를 실행한다.
- 해당 객체를 반환한다.

빈 객체를 만들고, 객체의 프로토타입을 Counter 프로토타입으로 변경하고, 객체를 this에 넣고, Counter를 호출한다. 마지막으로 push 함수가 들어있는 프로토타입을 갖고 있는 count가 들어있는 객체가 반환된다.



### 이것이 객체 지향?

Java에서 객체 지향을 접한 사람은 클래스 설명이 없어서 어색해 할 수 있다. Java는 프로그램을 만들 때 기본적으로 클래스를 만드는 언어다. 하지만 클래스란 그렇게 쓰는게 편하다는 이유로 만들어진 규칙에 불과하다. 언어 설계자의 의도를 파악하는 것이 중요하다.



## 방법 3: 클로저

### 클로저란?

클로저(Closure)는 객체적인 것을 만들기 위한 기술이다.

클로저라는 특수한 구문이 있는 것은 아니다. 함수를 함수 안에 정의하고 내포할 수 있는 정적 스코프가 있어서 함수를 반환값으로 사용하거나 변수에 대입하여 사용한다는 개념이다. 즉, 간단한 내포구조를 사용함으로써 상태 정보를 가진 함수를 만들 수 있는 것이다.

```javascript
function makeCounter(){
    var count = 0;
    function push(){
        count++;
    }
    return push;
}
c = makeCounter();
```



### 왜 클로저라고 부를까?

클로저라는 명칭에서 무언가 닫는다는 느낌이 든다. standard ML 학습서엔 다음과 같이 써있다.

> 자유 변수를 포함한 식을 '열린 식'이라고 부르고, 그 자유 변수의 바인딩을 조합함으로 해당 식을 닫고 있기 때문이다.
> -Ake Wikstorm, Functional programming using standard ML, Prentice-Hall, 1987.

앞의 코드로 설명하자면, 함수 push는 변수 count를 참조하지만 이 변수는 push 안에 정의되어 있지 않다. 이런 변수를 **자유 변수**라고 한다. 함수 push는 자유 변수를 포함하고 있기 때문에 열린 함수이다.

그리고 makeCounter 대응표에 count와 0이 연결되어 있는 것 처럼 값에 이름을 연결하는 것을 **바인딩**이라고 한다. 열린 함수 push가 makeCounter 대응표와 세트가 됨으로써 더 이상 그 외의 스코프에 변수를 찾으러 가지 않아도 되는 완결한 상태가 된다. 이것을 '닫았다'고 표현한다.



## 방법 4: 클래스

### Hoare가 생각한 클래스

Hoare은 ALGOL 확장안에서 다음과 같이 기술했다.

>  현실 세계 사물은 편의상 상호 배타적 종류로 분류될 수 있다.

Hoare가 생각한 클래스는 분류이다. C++이나 Java에서 사용하는 클래스는 복잡하지만 처음 시작은 분류였던 것이다.



### C++ 클래스

Bjarne Stroustrup은 다음과 같이 말했다.

> 클래스는 타입이다. 이거싱 C++을 이루는 중요한 원리이다. C++에서 class가 사용자 정의 타입을 의미한다면 왜 그것을 type이라고 부르지 않는가? 내가 class를 선택한 것은 계속 나오는 새로운 용어를 발명하는 것이 귀찮았기 때문이고, Simula의 class라면 아무도 당황하지 않을 것이라 판단했기 때문이다.

새로운 형을 사용자가 정의할 수 있도록 하자는 것이 C++가 클래스를 도입한 목적이다. C언어에도 여러 타입을 모아서 새로운 타입을 만드는 구조체라는 기법이 있다. 이후 여러 가지 기능이 추가된 것이다. 그중 하나가 사양으로서의 역할이다.



### 사양으로서 역할

C++에서 클래스는 사양을 표현한 것이기도 했다. 객체가 어떤 메소드를 갖고 있는지 사양을 선언하는 역할도 했다. Smalltalk과 C++의 가장 큰 차이이기도 하다.

Smalltalk의 메소드 호출은 '이런 메소드를 호출해줘'라는 메시지를 객체에 전달하는 것이며 메시지를 받은 객체가 어떤 동작을 할 것인지는 개체가 자유롭게 결정할 수 있었다. Smalltalk의 설계자인 Alan Kay는 이런 자유가 객체 지향의 중요한 요소라고 생각했다.



### 클래스의 3가지 역할

- 결합체를 만드는 생성기
- 어떤  조작이 가능한지에 대한 사양
- 코드를 재사용하는 단위