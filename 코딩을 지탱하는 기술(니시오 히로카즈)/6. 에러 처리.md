## 실패를 어떻게 전달할까?

프로그램은 실패를 한다. 대참사가 일어나기 전에 발견할 수 있도록 프로그래밍 언어에도 **실패를 알리는 구조** 가 필요하다.

#### 에러 처리를 구현하는 방법

1. 호출한 곳에서 반환값을 체크해 에러 처리
    - 실패를 놓친다.
    프로그래머가 반환값 확인을 잊어버렸을 때 실패를 놓치고 문제를 찾기 어려워진다.

    - 에러 처리 때문에 코드를 해석하기 어렵다.
    기존의 코드에 실패했을 경우 처리 코드가 채워져 흐름을 따라가기 어렵다.

2. 에러 처리 코드를 등록해 놓고, 실패 시 에러 처리 코드로 점프
    ```C
    int main(){
        if(!foo("A")) goto ERROR;
        if(!foo("B")) goto ERROR;
        return;
        ERROR:
        // 실패했을 때 처리
    }
    ```

## 에러 처리의 역사

#### UNIVAC

1950년에 나온 컴퓨터 UNIVAC에선 '오버플로우가 발생하면 n번지에 있는 명령을 실행한다'는 기능이 있다. 이런 기능을 **인터럽트(interrupt)** 라고 하며 현재도 다양하게 사용된다.

#### COBOL

1959년에 나온 COBOL에선 2가지 에러처리가 준비되어 있었다. 현재 예외처리와 달리 에러 종류를 늘릴 수 없었다.

#### PL/I

1964년에 나온 PL/I에선 COBOL과 달리 새로운 실패 종류를 추가할 수 있었고, 실패 종류에 따라 에러 처리 내용을 변경할 수 있었다. 그리고 추가한 **실패 종류를 프로그래머가 발생** 시킬 수 있었다. 현재 예외처리에서 중요한 역할을 하는 기능이 이때 탄생했다.

#### CLU

CLU는 1975년부터 **실패할 것 같은 처리를 묶고** 그곳에 에러 처리를 추가하는 예외 처리 메커니즘을 추가했다. 이는 현재 대부분의 언어가 채택하고 있는 '실패할 것 같은 처리를 묶은 후 에러 처리를 나중에 기술'하는 구문의 시초가 되었다.

#### C++

실패할 것 같은 부분을 try로, 발생한 실패를 처리하는 부분을 catch로 묶는 구문을 추가했다. 또한 예외를 발생시키기 위한 용어로 throw가 탄생했다. 기존에 다른 언어에서는 signal이란 명령어로 예외를 발생시켰지만 다른 라이브러리의 용어와 중복되어 사용되지 않았다.

#### Windows NT 3.1

1993년에 나온 Windows NT 3.1에선 OS에서도 에러 처리 구조가 필요하다고 생각했다. 그래서 **구조화된 예외처리(Structured Exception Handling, SEH)** 를 도입했다.

## 짝이 되는 처리

프로그래밍엔 짝이 되는 처리가 있다. 메모리 할당 해제나 파일을 열고 닫는 등이 이에 해당한다. 예외를 던질 가능성이 있는 코드는 각각의 장소에서 짝이 되는 처리를 하기가 어려워 졌다. 이 문제를 처리하는 방법은 3가지가 있다.

1. finally 사용

2. RAII(Resource Acquisition Is Initialization) 기술 사용
C++에선 짝이 되는 처리를 하기 위해 그 대상만을 위한 클래스를 만들어서 생성자(constructor)에서 열고 소멸자(destructor)에서 닫는다.

3. scope 사용
D언어에선 스코프(scope)를 도입한다. 스코프 가드를 사용해 스코프를 벗어날 때 등록한 처리를 수행한다.

## 어떤 경우 예외를 던질까?

#### 함수 호출 시 인자가 부족한 경우
- Python과 Ruby는 함수 호출 시점에 예외를 던진다.
- JavaScript는 **미정의를 의미하는 undefined** 를 사용해 처리를 계속 한다.

#### 배열 범위 밖에 있는 값에 접근하는 경우
- Python은 예외를 던진다.
- Ruby는 **없는 것을 의미하는 nil** 을 반환한다.
- JavaScript는 undefined를 반환한다.

언어마다 예외적 상황에 대한 의견이 다르다.

프로그래머도 실수는 피할 수 없다. 코드의 품질을 높이기 위해선 문제를 빨리 발견하는 것이 중요하다. 예외를 통해 실패를 놓치지 않을 수 있다. 이런 설계 이념을 **Fail First** 라고 한다.

## 예외 전파

대부분의 예외 처리에선 예외가 호출한 곳으로 전파된다. 어떤 함수에서도 에러가 처리되지 않으면 프로그램은 비정상 종료된다.

#### 단점
어떤 함수가 호출되는 모든 곳의 코드를 보지 않으면 어떤 예외를 발생시킬 수 있는지 알 수 없다. Java는 어떤 예외를 던질지 명시적으로 선언해 해결했다.

#### Java의 Checked Exception

Java에선 예외를 3가지로 세분화한다.

1. Error
2. Checked Exception
3. Unchecked Exception

이 중 Checked Exception은 메소드가 예외를 던지는 경우 선언해줘야 한다. 이를 통해 예외가 발생할 가능성을 놓치는 일이 발생하지 않는다.

이것은 좋은 방법이지만 모든 언어에선 잘 채용되지 않는다. try/catch에 기술하는 예외 개수가 방대해지거나 메소드에서 던질 예외가 추가되면 메소드가 호출되는 모든 곳을 수정해야 한다. 즉, 좋지만 불편하다.