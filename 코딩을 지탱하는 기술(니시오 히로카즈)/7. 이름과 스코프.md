## 왜 이름이 필요할까?

이름이 발명되기 전에는 번호(메모리 번지)를 사용했다. 우리가 알기 쉽도록 하기 위해 이름이 붙여졌다. 이를 위해 컴퓨터는 이름과 메모리 번지를 대응해 저장한다.



### 이름 충돌

초기 프로그래밍 언어에선 이 대응표를 프로그램 전체에서 공유했다. 이렇게 할 경우 프로그램의 흐름이 원하는 대로 동작하지 않을 수도 있다.

```perl
for($i = 0; $i < 10; $i++){
	&foo();
}

sub foo{
	$i = 0;
}
```

위 코드처럼 내부에서 i를 0으로 초기화해버리면 무한루프에 빠지게 된다.



### 충돌을 피하는 방법

이처럼 프로그램 전체에서 하나의 대응표를 사용하는 것을 **전역 스코프**라고 하고, i를 **전역변수**라고 한다. 전역변수의 변경은 프로그램 전체에 영향을 끼친다. 따라서 호출하는 곳에서 어떤 이름의 변수를 변경하고 있는지 파악해야 한다. 변수명 충돌을 피하는 방법은 다음과 같다.

1. 긴 변수명을 사용한다.
   ex) i_foo와 같이 함수명을 넣는다.
2. 스코프를 이용한다.



## 스코프의 진화

스코프(Scope)란 이름의 유효 범위이다. 프로그램 전체에서 이름이 충돌하지 않도록 이름의 유효 범위를 좁게 해서 관리한다. 함수 foo 내부의 i가 함수 foo 안에서만 유효하도록 하면 앞서 나온 문제를 해결할 수 있다. 스코프를 표현하는 방법에는 두 가지가 있다.



### 동적 스코프

함수 입구에서 원래의 값을 기록해두고 출구에서 원래의 값으로 되돌린다.

```perl
sub foo{
	$old_i = $i;
	# 여러 가지 처리
	$i = $old_i;
}
```



하지만 변수를 변경한 후 다른 함수를 호출한 경우 그 함수에 영향을 미친다. 동적 스코프를 통해 전역변수에는 영향을 주지 않게 되었지만, 함수 내에서 다른 함수를 호출한 경우 영향을 미치게 된 것이다.

```perl
sub foo{
	$old_i = $i;
	# 여러 가지 처리
	&bar();
	$i = $old_i;
}
sub bar{
	print "$i";
}
```



동적 스코프에선 변경값이 호출되는 곳에 영향을 주기 때문에 호출되는 곳의 코드를 봐야만 알 수 있다. 코드가 많아질 수록 함수가 어디에서 호출되고 있는지 파악하기 어렵기 때문에 문제가 된다. 이 문제는 함수가 호출될 때 마다 새로운 대응표를 만드는 방법으로도 해결할 수 있다. 동적 스코프는 다음과 같은 처리를 한다.

1. 함수에 들어갔을 때 새로운 대응표를 준비한다.
2. 함수 내에서 처리는 새로운 대응표에 기록한다.
3. 함수를 벗어날 때 대응표를 제거한다.

동적 스코프로 만들어진 대응표는 전역에서 참조할 수 있다. 함수 안에서 변수를 참조할 때 가까운 대응표부터 순서대로 확인한다.



### 정적 스코프

다수의 함수에서 대응표를 공유하고 있는 것이 동적 스코프의 문제다. 정적 스코프는 함수별로 대응표를 나눈다. 정적 스코프는 다음과 같은 처리를 한다.

1. 함수에 들어갔을 때 **해당 함수 전용**의 새로운 대응표를 준비한다.
2. 함수 내에서 처리는 새로운 대응표에 기록한다.
3. 함수를 벗어날 때 대응표를 제거한다.

정적 스코프로 만들어진 대응표는 해당 함수 안에서만 참조할 수 있다. 해당 함수의 대응표에 값이 없는 경우 전역 대응표를 확인한다. 이처럼 **함수 안에서의 변경이 함수 밖까지 영향을 주지 않는 것이 정적 스코프**이다.



동적 스코프 덕분에 다른 장소에서 이름이 사용되고 있는지 걱정할 필요가 없어져서 짧은 변수명을 사용할 수 있게 되었다. 하지만 동적 스코프에도 부족한 점이 남아있었고 이를 해결하기 위해 정적 스코프가 개발되었다.



## 정적 스코프는 완성체인가?

처음부터 정적 스코프를 채택한 Python에는 빌트인, 전역, 지역 계층이 있다. 프로그램 전체의 대응표인 빌트인과, 파일 단위의 대응표인 전역 대응표, 함수별 대응표인 지역 대응표이다. Python은 대입과 함께 변수를 만들기 때문에 함수 안의 변수가 함수 밖에 영향을 미치지 않는다. 이 설계에도 문제점이 있다.



### 내포 함수의 문제점

첫 번째는 '내포된 것처럼 보이는 스코프가 실제로는 내포되지 않다'는 점이다. Python은 함수를 내포할 수 있는 언어라서, 함수 안에서 새로운 함수를 정의할 수 있다.

```python
x = "global";
def foo():
    x = "foo"
    def bar():
        print x
    bar()
foo()
```

자연스러운 흐름대로라면 "foo"가 출력되어야 하지만 "global"이 출력된다. Python 2.0까지는 지역 스코프에서 변수를 발견하지 못하면 전역 스코프를 참조했다. 이후 Python 2.1에서는 "foo"를 출력하도록 수정되었다.



### 외부 스코프에 재귀속되는 문제

두 번째는 '내포한 스코프의 외부 변수를 변경할 수 없다'는 점이다. 이 문제는 Python이 대입과 함께 변수를 만들기 때문에 발생한다. 함수 안에서 대입하면 지역 변수가 된다. 대입은 해당 스코프에 같은 이름의 변수가 있으면 재귀속시키고 없으면 새로운 지역 변수를 작성한다. 이는 외부 스코프에 있는 변수를 변경할 수 없다는 것을 의미한다.



### Python의 해결 방법

Python 3.0에선 함수 서두에서 변수를 `nonlocal`로 선언해서 해결한다.



### Ruby의 해결 방법

Ruby도 변수 선언을 요구하지 않는 언어로 Python과 같은 문제가 있다.

Ruby엔 함수와 같은 기능을 하는 메소드와 블록이 존재한다. Ruby 1.9에선 메소드를 내포한 경우 스코프는 내포하지 않는다. 메소드 안에서 블록을 만든 경우 메소드의 지역 스코프에 있는 이름은 메소드의 지역 변수로 간주하고, 그 이외엔 블록의 지역변수로 한다.



## 정리

현재는 정적 스코프가 주로 사용되고 있다. 하지만 동적 스코프가 무용지물이 된 것은 아니다. 어떤 처리를 하고 있는 중간에 일시적으로 변수의 값을 바꾸고 나중에 되돌리는 처리를 하고 있다면 동적 스코프를 만들고 있는 것과 같다. 또한 예외처리도 동적 스코프와 닮아있다.

객체지향에서 접근제어자도 스코프와 닮아있다. protected는 호출한 곳에서 변경한 것이 선언한 곳에 영향을 끼치는 동적 스코프와 닮아있다. 영향 범위가 코드 상의 한 곳에 모여지지 않는 단점이 있다.

Java는 정적 스코프 언어이지만 클래스는 소스 코드 어디서든 참조할 수 있다. 즉, 클래스는 전역 스코프이다. 클래스는 이름이 계층적으로 이루어져 있어서 전역 스코프의 충돌 문제를 피하고 있다. 하지만 전역 변수와 클래스의 static 멤버도 소스 코드 어디서든지 바꿀 수 있다는 위험은 존재한다.