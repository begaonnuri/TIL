## 병행 처리란?

복수의 처리를 동시에 실행하는 것을 병행처리라고 한다.

예전 컴퓨터인 EDSAC 등에선 계산을 실행하면 계산이 끝날 때 까지 기다려야 했다. 하나의 처리만을 할 수 있었다. 병행 처리를 하기 위해 프로세스와 스레드같은 개념이 만들어졌다. 병행 처리가 새로운 문제를 일으키게 되자 락과 파이버 등의 개념이 나왔다.



## 잘게 분할해서 실행한다

CPU 안에 복수 개의 회로(멀티코어)가 복수의 처리를 실행한다. 프로그램이 내부적으로는 잘게 분할해서 실행되고 있는 것이다. 이것이 병행 처리의 가장 중요한 개념이다.



## 처리를 변경하는 2가지 방법

언제 교대할 것인가를 정하는 방법은 2가지가 있다.



### 협력적 멀티태스크

하나는 적절한 시점에 교대하는 방법이다. 처리가 일단락 되는 시점에 자발적으로 교대를 한다. 이 방법을 협력적 멀티태스크라고 한다.

이 방법에서 처리가 오래 지속되면 다른 처리는 계속 기다려야 하는 문제가 있다.



### 선점적 멀티태스크

다른 하나는 일정 시간에 교대하는 방법이다. 이 방법에선 태스크 스케줄러라는 프로그램이 존재한다. 테스크 스케줄러가 일정 시간마다 처리를 중단시켜 다른 처리가 실행될 수 있도록 한다.



## 경합 상태 방지법

선점적 멀티태스크는 프로그램을 사용하는 사람 입장에선 편리하지만, 프로그램을 만드는 사람 입장에선 중단 명령을 신경써야 하기 때문에 복잡하다. 이 경우 프로그램이 경합 상태(Race condition)에 빠질 수 있다. 스레드 세이프하지 않다고도 표현한다.



### 경합 상태의 3가지 조건

경합 상태가 발생하기 위해선 다음 조건을 모두 만족해야 한다.

- 2가지 처리가 변수를 공유하고 있다.
- 적어도 하나의 처리가 그 변수를 변경한다.
- 한쪽 처리가 마무리되기 전에 다른 한쪽의 처리가 끼어들 가능성이 있다.

반대로 말하면 3가지 조건 중 하나라도 제거할 수 있다면 병행 실행시에도 안전한 프로그램을 만들 수 있다.



### 공유하지 않는다

#### 프로세스

UNIX에선 실행 중인 프로그램을 프로세스라고 부른다. 프로세스는 메모리를 공유하지 않기 때문에 복수의 프로그램이 경합 상태를 발생시키지 않는다. 데이터베이스 접속과 파일 처리 등만 주의하면 된다.

메모리를 공유하지 않는 것은 너무 엄격한 구조였기 때문에 UNIX 출시 후 시간이 흘러 경량 프로세스가 만들어졌다. 이것이 스레드다. 현재도 스레드를 사용해서 공유 메모리를 어떻게 다뤄야 할지 고심해가면서 프로그램이 만들어지고 있다.



#### 액터 모델

액터 모델은 메모리를 공유하지 않는 또 다른 흐름으로 병행 처리를 표현하기 위한 모델이다. 액터 모델에선 메모리를 공유하는 것이 아니라 메시지를 보낸다. 작업을 중단하고 전환하는것은 비효율적이기 때문에 작업을 처리해 달라고 메시지를 보내고 다른 작업을 처리한다.

다른 처리가 끝날 때 까지 기다리는 것은 낭비이기 때문에 비동기로 처리가 이루어진다. 이런 처리는 메시지 교환에서 주로 사용된다. Twitter나 Facebook 등 대량의 사용자 메시지를 취급하는 서비스에선 액터 모델이 적합하다.



### 변경하지 않는다

이 방식을 강하게 따라서 모든 값이 변경 불가능한 Haskell과 같은 언어가 있다. 보다 현실적으로 일부 변수를 변경할 수 없도록 하는 언어도 있다. C++에서 const를 붙이거나 Scala의 val이 이에 해당한다. Java에선 Immutable 패턴이 자주 사용된다. private 필드를 만들고 getter를 만들지만 setter를 만들지 않는 패턴이다.



### 끼어들지 않는다

#### 협력적 스레드의 사용

다른 작업에 끼어들지 않는 방법 중 하나는 파이버(fiber), 코루틴(coroutine), 그린 스레드(Green thread) 등의 기법을 사용하는 것이다. 스레드가 선점성을 가지기 때문에 협력적 스레드를 만들면 된다는 발상이다. Ruby의 Fiber 클래스나 Python, JavaScript의 Generator가 그 예다.



#### 끼어들면 곤란해지는 처리에 표식을 붙인다

다른 방법은 표식을 공유하는 것이다. 예를 들어 어떤 메모리 값이 0이 아니면 다른 스레드가 끼어들 수 없도록 정하는 것이다. 각 스레드는 작업을 하기 전에 메모리 값을 체크한다.

이 방법에는 락(Lock), 뮤텍스(Mutex), 세마포어(Semaphore)와 같은 기법이 있다. 모두 작업에 '사용중'이라는 표식을 붙이는 것이다. 표식을 확인하지 않고 실행하는 스레드가 있다면 아무 소용 없다.

이 방법들이 나온 이후 모니터라는 개념이 나왔다. 모니터 개념은 Java에서는 구현해 널리 사용됐다. synchronized 블록으로 감싸기만 하면 손쉽게 락을 걸 수 있게 됐다.



## 락의 문제점과 해결책

### 락의 문제점

#### 교착상태가 발생한다

A, B가 X, Y를 처리한다고 할때, A는 X -> Y 순서로 락을 걸고, B는 Y -> X 순서로 락을 걸었을 때 서로 락이 풀리는 것을 기다리게 된다.

이것이 교착상태(Deadlock)이다. 프로그래머는 교착상태에 빠지지 않기 위해 무엇에 락을 걸어야 하는지, 어떤 순서로 락을 걸어야 하는지 신경써야 한다.



#### 합성할 수 없다

또한 락에는 합성할 수 없다는 문제점이 있다. 리스트 X에서 값을 꺼내 리스트 Y에 추가한다고 할 때 X에서 값을 꺼낸 후 Y에 추가하기 전 상태에 락을 걸어야 하는데, 프로그래머는 2가지 처리를 묶는 새로운 락을 만들어야 한다.



### 트랜잭션 메모리

프로그래머가 락을 신경쓰지 않도록 하는 방법이 트랜잭션 메모리다. 데이터베이스의 트랜젝션 기법을 메모리에 적용한 것으로 일시적으로 별도의 버전을 만들어 변경하고 처리가 끝나면 반영하는 것이다. 이 경우 다른 스레드가 읽는 처리를 하더라도 문제가 발생하지 않는다.

하지만 쓰는 처리가 끼어들면 일시적으로 만든 별도 버전은 버리고 다시 처음부터 변경한다. 쓰는 처리의 빈도가 높을 때는 성능이 나빠질 수 있다.



## 정리

병행처리는 예전부터 지금까지 많은 사람을 고민하게 만들고 있다. 공유 -> 비공유 -> 공유, 협력 -> 비협력 -> 협력, 하드웨어 -> 소프트웨어 -> 하드웨어 처럼 결정되지 않고 방황하고 있다. 양쪽 모두 익혀 균형있게 사용해야 한다.