## 상속이란?

클래스의 가장 기본적인 의미는 분류다. 같은 분류는 같은 속성을 공통으로 가지고 있다.

클래스에서 선언한 것을 자식 클래스에도 이어지게 하는 것이 상속이다.



### 상속에 관한 다양한 접근법

#### 일반화/특수화

첫 번째는 부모 클래스로 일반적인 기능을 구현하고 자식 클래스로 목적에 특화된 기능을 구현하는 것이다. 클래스 = 분류라는 접근과 일치한다.

이 경우 자식 클래스는 부모 클래스의 일종이다.



#### 공통 부분을 추출

두 번째는 복수 클래스의 공통 부분을 부모 클래스로 추출하는 것이다.

이 경우 자식 클래스는 부모 클래스의 일종이 아니다.



#### 차분 구현

세 번째는 상속 후 변경된 부분만을 구현하는 것이다. 재사용을 위해 상속을 사용해 구현을 편하게 하겠다는 발상이다.

이 경우 자식 클래스는 부모 클래스의 일종이 아니다.



### 상속은 양날의 검

이렇게 여러 가지 사용법이 있다는 것은 상속의 자유도가 높다는 뜻이다. `goto`문을 많이 사용하면 코드가 복잡해지는 것 처럼 상속을 많이 하면 코드가 복잡해진다. 특히 세 번째인 차분 구현은 깊은 상속 트리를 만들어 코드가 복잡해진다.

사용하는 메소드의 출처를 확인하려면 상속 관계를 따라가면서 많은 코드를 확인해야 한다. 또한 상위 클래스에서 메소드를 변경할 시 그 모든 영향이 자식 클래스까지 이르게 된다. 코드를 이해하기 쉽게 하려면 상속 트리의 깊이를 낮추는 것이 중요하다.



### 리스코프 치환 원칙

CLU라는 언어의 설계자인 Liskov가 만든 것으로, T형의 객체 x에 대해 속성 q(x)가 항상 참이라고 가정할 때 S가 T의 파생형이면 S형의 객체 y에 대해 속성 q(y)가 항상 참이어야 한다는 원칙이다.

클래스 T의 객체에 항상 성립하는 조건이 있다면 T의 자식 클래스인 S의 객체에도 조건이 항상 성립해야 한다는 것이다.

Java에선 T타입의 변수에 S객체를 넣을 수 있다. 하지만 리스코프 치환 원칙을 만족하지 않는 S가 생길 수 있다. 클래스 상속 관계와 타입의 정합성을 위해 리스코프 치환원칙을 지켜야 한다. 상속은 is-a 관계여야 한다고 표현하기도 한다.

리스코프 치환 원칙은 매우 엄격하다. 현재는 원칙을 지키고 있다고 해도 이후 속성이 증가해 치환 원칙이 깨질 수도 있다.



## 다중 상속

### 하나의 사물을 복수로 분류

하나의 사물이 복수의 분류에 해당하는 경우가 있다. 이것을 프로그래밍 언어로 모델화한 것이 다중 상속이다.



### 코드 재사용에 편리한 다중 상속

다중 상속은 코드 재사용 방법으로도 매우 좋은 도구다.

예를 들어 윈도우 클래스를 상속해서 '메뉴 바가 있는 윈도우' 클래스와 '스크롤 바가 있는 윈도우' 클래스를 만들 수 있고, 만든 두 클래스를 상속해 '메뉴 바와 스크롤 바가 있는 윈도우' 클래스를 만들 수도 있다.



## 다중 상속의 문제점

다음 코드처럼 복수의 부모 클래스에 같은 이름의 정보가 있으면 문제가 발생한다.

```python
class ParentA:
    x = "A"
    
class ParentB:
    x = "B"

class Child(ParentA, ParentB):
    pass
```



### 해결책 1: 다중 상속을 금지한다

다중 상속을 버리게 되면 문제는 해결할 수 있지만 다중 상속의 편리함 또한 버리게 된다. 그래서 Java에선 재사용을 목적으로 한 상속을 피하려고 하는 움직임을 보인다. Abstract Window Toolkit에선 상속해서 각종 메소드를 오버라이드해서 사용한다는 규칙이 있었다. 하지만 현재 Standard Widget Toolkit에선 상속해선 안된다는 규칙을 적용하고 있다.



#### 위임

상속을 대신해서 발달한 것이 위임(delegation)이다. 코드를 갖고있는 클래스 객체를 만들고 필요할 때 처리를 위임하는 방법이다.

위임의 참조도 클래스 내에서 하는 것이 아니라 외부에서 주입하는 것이 편리하다. 이런 발상으로 의존성 주입이 탄생했다.



#### 인터페이스

인터페이스는 코드를 갖고 있지 않은 클래스다. 인터페이스를 상속받은 클래스가 가져야 하는 메소드만 정의하고 있다.

다중 상속시 발생하는 문제는 복수의 코드가 충돌했을 때 발생하는데, 메소드에 대한 정보는 여러 개 있어도 상관 없기 때문에 문제가 발생하지 않는다.



### 해결책 2: 메소드 해결 순서를 고민한다.

탐색 순서를 정하면 해결할 수 있다는 접근을 한 언어도 있다.



#### 깊이 우선 탐색의 문제점

예를 들어 어떤 클래스 A를 상속받는 B, C가 있고, B, C를 상속받는 D가 있다. 이런 형태를 마름모 상속이라고 한다.

```python
class A:
    x = "A"
    
class B(A):
    pass

class C(A):
    x = "B"

class D(B, C):
    pass
```

Python 2.1에는 깊이 우선 탐색을 적용해 A가 출력된다. 하지만 이 경우 x를 재정의해도 영향을 주지 않기 때문에 문제가 된다. Python 2.3부턴 이 문제를 해결하기 위해 C3 선형화를 사용한다.

C3선형화는 2가지 제약 조건을 만족하도록 클래스에 순서를 매겨 정렬한다.

- 부모 클래스는 자식 클래스보다 먼저 탐색되지 않는다.
- 어떤 클래스가 복수의 부모 클래스를 상속하고 있으면 먼저 만들어진 클래스가 우선이다.



## 해결책 3: 처리를 섞는다.

재사용하고 싶은 기능만 모은 작은 클래스를 만들어서 기능이 필요한 클래스에 섞어서 사용한다. 이렇게 기능만 모은 클래스를 믹스-인(Mix-in)이라고 한다.

마름모 상속은 믹스-인을 사용해 다른 형태로 바꿀 수 있다. 마름모 상속이 없어질 뿐만 아니라 상속 트리의 깊이도 한 단계 줄어든다.



#### Python의 경우

믹스-인 클래스는 재사용 단위로 사용하기 위해 최소한의 메소드만 정의하고 인스턴스 만들어서 사용하진 못한다. 이 클래스는 인스턴스 만드는 것을 고려하지 않는다는 것을 나타내기 위해 이름에 MixIn을 붙인다.



#### Ruby의 경우

Ruby는 클래스는 단일 상속이지만 모듈은 얼마든지 믹스-인해도 된다는 규칙을 채택하고 있다. 모듈은 클래스에서 인스턴스 생성 기능을 뺀 것이다. 클래스의 다중 상속을 금지했지만 모듈의 믹스-인으로 코드를 재사용하게 하면 문제가 없다는 것이다.



## 해결책 4: 트레이트

왜 다중 상속은 이런 문제를 겪고 있는 것일까? 클래스는 2가지 상반되는 역할이 있다.

- 인스턴스를 만들기 위한 역할
- 재사용 단위

첫 번째 역할을 하기 위해선 클래스는 필요한 모든 것을 갖고 있는 완결된 형태의 큰 클래스여야 한다. 하지만 두 번째 역할을 하기 위해선 필요 없는 기능을 갖고 있지 않은 작은 클래스여야 한다.

클래스가 첫 번째 역할을 할 때 재사용 단위로는 너무 크다. 그래서 재사용 단위라는 역할에 특화된 작은 구조로 만든 것이 트레이트다. 트레이트는 메소드 묶음을 의미한다. Ruby의 모듈과 흡사하다. 하지만 Ruby에선 메소드가 충돌할 경우 마지막 메소드로 덮어쓰여 지지만 트레이트는 에러를 발생시킨다.

트레이트는 상속처럼 기존 트레이트에 일부 메소드를 덮어쓰기해서 새로운 트레이트를 만들 수도 있다. 또한 복수의 트레이트를 조합해 새로운 트레이트를만들 수도 있다.



## 정리

무엇을 사용해 문제를 해결해야 할지는 상황에 따라 다르다.

하지만 클래스가 '재사용 단위'와 '인스턴스 생성기'라는 상반된 역할을 한다는 트레이트의 사고방식은 훌륭하다. 클래스라는 개념이 객체 지향의 근간이지만 클래스도 단순한 형태로 시작해서 복잡한 형태로 발전했다. 트레이트도 점점 발전할 것이다.