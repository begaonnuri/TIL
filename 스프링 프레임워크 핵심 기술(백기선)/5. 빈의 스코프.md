## 빈의 스코프

빈의 기본 스코프는 싱글톤이기 때문에 우리가 지금까지 등록한 모든 빈은 싱글톤 스코프이다. 싱글톤 스코프란 애플리케이션 전반에 걸쳐서 해당 빈의 인스턴스가 오직 한 개인 것이다.

인스턴스를 새로 만들어야 하는 경우 프로토타입 스코프로 설정한다. 프로토타입 스코프란 매번 새로운 인스턴스를 만들어서 사용하는 스코프이다.



## 빈을 참조할 때 문제

프로토타입 스코프의 빈이 싱글톤 스코프의 빈을 참조해서 사용하는 것은 문제가 없다. 하지만 **싱글톤 스코프의 빈이 프로토타입 스코프의 빈을 사용하는 경우는 문제**가 된다.

싱글톤 스코프의 빈은 인스턴스가 한번 생성되는데, 그때 필드로 참조하고 있는 프로토타입 스코프의 빈도 값이 정해지기 때문에 프로토타입 스코프임에도 인스턴스가 변경되지 않는다.



#### 1. 프록시 모드를 설정해 해결

`proxyMode = ScopedProxyMode.TARGET_CLASS`로 설정해서 해결한다. 다른 빈이 해당 빈을 참조할 때 해당 빈을 클래스 기반의 프록시로 감싸라는 뜻이다.

```java
@Component @Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class Proto {}
```

싱글톤 스코프의 빈이 프로토타입 스코프의 빈을 직접 참조하면 안되기 때문에 프록시를 거쳐서 참조하도록 한다. **싱글톤 스코프의 빈이 프로토타입 스코프의 빈을 직접 참조할 경우 프로토타입 스코프의 빈을 바꿔줄 수 없기 때문에 매번 바꿔줄 수 있는 프록시로 감싸는 것이다.**

프로토타입 스코프의 빈을 상속받은 클래스를 프록시로 만들어주는 CGLIB라는 써드파티 라이브러리가 있다. **CGLIB를 통해 클래스도 프록시로 만들 수 있다.** JDK 안에 있는 **다이나믹 프록시는 인터페이스 프록시밖에 만들 수 없다.** `proxyMode = ScopedProxyMode.INTERFACES`로 다이나믹 프록시를 설정할 수 있다.

실질적으로 **프록시 빈을 프로토타입 스코프의 빈에 주입해주는 것**이다. 프록시 빈도 프로토타입 빈을 상속받아 만들어졌기 때문에 타입이 같아지고 주입할 수 있는 것이다.



#### 2. ObjectProvide를 사용해 해결

프로토타입 스코프의 빈을 사용하는 부분에서 `ObjectProvider<T>`를 사용해 해결한다.

```java
public class Single {
  @Autowired
  private ObjectProvider<Proto> proto;
  
  public Proto getProto() {
    return proto.getIfAvailable();
  }
}
```

코드 내부에 스프링 의존적인 코드가 들어있기 때문에 좋지 않다. 프록시 모드를 설정하는 것 처럼 빈의 스코프를 선언하는 부분에만 스프링 관련 설정을 하고 내부는 최대한 POJO스럽게 유지하는 것이 더 낫다.



## 싱글톤 객체 사용시 주의할점

**싱글톤 객체를 사용할 경우 프로퍼티가 공유된다.** 내부의 필드값이 Thread safe할 것이라고 보장할 수 없다. Thread safe한 방법으로 코딩해야한다.

모든 싱글톤 스코프의 빈들은 기본적으로 ApplicationContext가 만들어질 때 만들어진다. 초기 구동시 시간이 더 걸릴 수 있다.