데이터베이스에선 여러 개의 테이블에 데이터를 나눠서 저장하는데, **나누어진 데이터를 하나로 묶어 결과를 내는 방법이 테이블 결합**이다.



## 곱집합과 교차결합

곱집합은 두 개의 집합을 곱하는 연산 방법으로 '적집합' 또는 '카티전 곱(Cartesian product)'이라고도 불린다.



#### 교차결합

`SELECT`문의 `FROM`에 두 개의 테이블을 지정하면 두 테이블은 교차결합을 한다. 즉, 곱집합으로 계산된다.

**sample72_x 테이블**

| x    |
| ---- |
| A    |
| B    |

**sample72_y 테이블**

| y    |
| ---- |
| 1    |
| 2    |

**교차결합 후 결과**

```sql
SELECT * FROM sample72_x, sample72_y;
```

| x    | y    |
| ---- | ---- |
| A    | 1    |
| B    | 1    |
| A    | 2    |
| B    | 2    |



#### UNION 연결과 결합 연결의 차이

**집합 연산**에서는 테이블의 데이터가 **세로 방향**으로 늘어나거나 줄어든다. **테이블 결합**에서는 **가로 방향**으로 데이터가 늘어난다.



## 내부결합

교차결합을 할 때 테이블 수가 많아지면 집합이 너무 커지기 때문에 교차결합보다 내부결합을 자주 사용한다.

다른 테이블의 데이터를 참조해야 하는 경우, 참조할 테이블의 기본키와 동일한 이름과 자료형으로 열을 만들어서 연결하는 경우가 많다.  다음의 예제에서 상품코드가 이에 해당한다.

**상품 테이블**

| 상품코드 | 상품명    | 브랜드명 | 가격 | 분류     |
| -------- | --------- | -------- | ---- | -------- |
| 0001     | A식품     | X브랜드  | 100  | 식료품   |
| 0002     | B식품     | X브랜드  | 200  | 식료품   |
| 0003     | C생활용품 | Y브랜드  | 1980 | 생활용품 |
| 0001     | A식품     | X브랜드  | 100  | 식료품   |

**재고 수 테이블**

| 상품코드 | 입고날짜   | 재고수 |
| -------- | ---------- | ------ |
| 0001     | 2020-01-03 | 200    |
| 0002     | 2020-02-10 | 500    |
| 0003     | 2020-02-14 | 10     |

두 집합을 통해서 원하는 데이터를 검색하려면 상품코드가 같다는 조건이 필요하다. 이러한 조건을 **결합조건**이라고 한다. 결합조건 이외에 원하는 조합을 검색할때 쓰는 조건을 **검색조건**이라고 한다.

이렇게 **교차결합으로 만들어진 곱집합에서 원하는 조합을 검색하는 것을 내부결합(Inner Join)**이라고 한다.

```sql
SELECT 상품.상품명, 재고수.재고수 FROM 상품, 재고수
WHERE 상품.상품코드 = 재고수.상품코드 -- 결합조건
AND 상품.상품분류 = '식료품'; -- 검색조건
```



## `INNER JOIN`으로 내부결합하기

최근엔 결합조건이 아닌 `INNER JOIN` 키워드를 사용해 내부결합을 한다. 위의 쿼리문을 `INNER JOIN`을 사용해 바꾸면 다음과 같다.

```sql
SELECT 상품.상품명, 재고수.재고수 FROM 상품
INNER JOIN 재고수
ON 상품.상품코드 = 재고수.상품코드
WHERE 상품.상품분류 = '식료품';
```

기존엔 `FROM`에서 `,`를 통해 테이블을 구분했지만, `INNER JOIN` 을 통해 테이블을 구분한다.  또한 `WHERE`에서 결합조건을 지정했지만, `ON`을 통해 결합조건을 지정한다.



## 내부결합을 활용한 데이터 관리

다음과 같은 브랜드 테이블이 있다. 코드와 이름으로 열을 지정하고 코드가 기본키가 되는 패턴은 자주 나오는 패턴이다.

**브랜드 테이블**

| 브랜드코드 | 브랜드명 |
| ---------- | -------- |
| B0001      | X브랜드  |
| B0002      | Y브랜드  |

**상품 테이블**

| 상품코드 | 상품명    | 브랜드코드 | 가격 | 분류     |
| -------- | --------- | ---------- | ---- | -------- |
| 0001     | A식품     | B0001      | 100  | 식료품   |
| 0002     | B식품     | B0001      | 200  | 식료품   |
| 0003     | C생활용품 | B0002      | 1980 | 생활용품 |
| 0001     | A식품     | B0001      | 100  | 식료품   |



상품명과 메이커명을 출력하면 다음과 같다.

```sql
SELECT P.상품명, B.브랜드명 FROM 상품 P
INNER JOIN 브랜드 B
ON P.브랜드코드 = B.브랜드코드;
```

| 상품명    | 브랜드명 |
| --------- | -------- |
| A식품     | X브랜드  |
| B식품     | X브랜드  |
| C생활용품 | Y브랜드  |

상품 테이블의 브랜드명을 보면 중복이 존재한다. 하지만 기본키는 상품 코드에만 적용되어있어서 제약에 위반되지 않는다. 브랜드 테이블 역시 브랜드 코드에 기본키가 지정되어 있어서 중복을 허용하지 않는다. 이처럼 **테이블을 결합할 때는 일대다 혹은 다대일인지, 아니면 일대일인지와 같이 결합하는 테이블의 관계가 중요**하다.



#### 외부키

브랜드 테이블의 브랜드 코드는 기본키이다. 하지만 상품 테이블의 브랜드코드는 외부키로 다른 테이블의 기본키를 참조하는 열이다.



#### 자기결합(Self Join)

자기결합은 테이블에 별명을 붙일 수 있는 기능을 이용해 같은 테이블끼리 결합하는 것이다. 자기결합에선 좌우 테이블이 같은 테이블이기 때문에 구분하기 위해 반드시 별명을 붙여야 한다.

자기결합은 자기 자신의 기본키를 참조하는 열을 자기 자신이 갖는 데이터 구조로 되어 있을 경우 자주 사용한다.



## 외부결합

외부결합이라도 교차결합으로 결합 조건을 지정해 검색한다는 사고방식은 같다. **외부결합은 한쪽 테이블에만 데이터가 존재할 때 결합하는 방법**이다.

상품 테이블에서 새로운 상품이 추가되었을 때 재고 수 테이블에는 아직 데이터가 없다. 내부결합을 해도 재고 수 테이블에 데이터가 존재하지 않기 때문에 해당 상품이 제외된다. 이런 경우 외부결합을 통해 해결할 수 있다.

```sql
SELECT P.상품명, C.재고수
FROM 상품 P LEFT JOIN 재고수 C
ON C.상품코드 = C.상품코드;
```

이때 재고 수 테이블에는 데이터가 없기 때문에 `NULL`로 표시된다.

| 상품명   | 재고수 |
| -------- | ------ |
| A상품    | 200    |
| B상품    | 500    |
| 추가상품 | NULL   |

기준이 되는 상품 테이블이 `JOIN`의 왼쪽에 있기 때문에 `LEFT JOIN`인 것이다. 상품 테이블을 오른쪽에 지정하거나 재고 수 테이블을 기준으로 삼을 경우 `RIGHT JOIN`을 사용한다.



#### 구식방법에서의 외부결합과 표준 SQL

MySQL은 비교적 최근에 나온 데이터베이스이기 때문에 구식 방법을 통해 내부결합은 가능해도 외부결합은 할 수 없다.

Oracle에선 데이터가 존재하지 않을 수도 있는 열에 `(+)`라는 기호를 붙여 조건식을 지정한다.

```sql
SELECT P.상품명, C.재고수
FROM 상품 P, 재고수 C
WHERE P.상품코드 = C.상품코드 (+);
```

SQL Server에서는 `*=` 또는 `=*`를 사용해서 외부결합을 했다. 이처럼 예전엔 DBMS 제품에 따라 서로 다른 방법으로 외부결합을 지원했다. 하지만 현재는 표준화로 인해 내부결합은 `INNER JOIN`, 외부결합은 `LEFT JOIN`이나 `RIGHT JOIN`을 사용하는 것을 권장한다.