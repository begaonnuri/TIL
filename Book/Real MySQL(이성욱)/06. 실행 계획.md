## 개요

### 쿼리 실행 절차

MySQL 서버에서 쿼리가 실행되는 과정은 크게 3가지이다.

1. 사용자의 SQL문을 MySQL 서버가 이해할 수 있는 수준으로 분리
2. SQL의 파스 트리를 이용해 어떤 테이블부터 읽고 어떤 인덱스를 사용해 테이블을 읽을지 선택
3. 2번째 단계에서 결정된 읽기 순서나 선택된 인덱스를 사용해 스토리지 엔진에서 데이터를 가져옴

1단계를 `SQL 파싱(Parsing)`이라고 하며 MySQL 서버의 SQL 파서라는 모듈로 처리한다. 문법 오류는 여기서 판별된다.

2단계에선 최적화 및 실행 계획 단계를 수립한다. `SQL 파스 트리`를 참조해 다음과 같은 처리를 한다.

- 불필요한 조건 제거 및 복잡한 연산 단순화
- 테이블에 조인이 있는 경우 테이블을 읽는 순서 결정
- 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
- 가져온 레코들을 임시 테이블에 넣고 다시 한번 가공해야하는지 결정

3단계에선 수립된 계획대로 스토리지 엔진에 레코드를 요청하고 MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬한다.



### 옵티마이저의 종류

옵티마이저는 데이터베이스 서버에서 두뇌에 해당된다. 옵티마이저의 종류는 크게 2가지다.

- 비용 기반 최적화(Cost-based optimizer, CBO) : 현재 대부분의 DMBS가 사용
- 규칙 기반 최적화(Rule-based optimizer, RBO) : 예전 오라클에서 사용

규칙 기반 최적화는 테이블의 레코드 수나 선택을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다.

비용 기반 최적화는 쿼리를 처리하는 여러가지 방법을 만들어놓고 비용과 통계 정보를 통해 비교해서 최소 비용의 방법으로 실행 계획을 수립한다.



### 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보다. 잘못 된 통계 정보 때문에 비효율적인 쿼리가 실행될 수도 있다.

MySQL도 비용 기반 최적화를 사용하지만 다른 DBMS보다 통계 정보가 다양하진 않다. MySQL의 통계 정보는 레코드 수와 인덱스의 유니크한 값 개수 정도다. MySQL에서 통계 정보는 동적으로 순간순간 자동으로 변경된다. 레코드 수가 많지 않으면 통계 정보가 부정확하기 때문에 `ANALYZE` 명령을 통해 통계 정보를 갱신해야 한다.

ANALYZE를 실행하는 동안 MyISAM 테이블은 읽기만 가능하고, InnoDB 테이블은 읽기와 쓰기 모두 불가능하다. MyISAM 테이블의 ANAYLZE는 인덱스 전체를 스캔해서 많은 시간이 소요되지만 InnoDB는 인덱스 페이지 8개를 랜덤으로 선택해서 분석해서 상대적으로 빠르다.

InnoDB의 통계 수집 페이지 수를 `innodb_stats_sample_pages` 파라미터로 지정할 수 있지만 InnoDB는 통계 정보를 자주 수집하기 때문에 페이지 수를 기본값 8개에서 2-3배를 넘지 않게 설정하는 것이 좋다.



## 실행 계획 분석

기본적인 실행 계획은 `EXPLAIN` 명령을 통해 확인할 수 있다. 상세한 실행 계획은 `EXPLAIN EXTENDS`나 `EXPLAIN PARTITIONS` 명령을 통해 확인할 수 있다.

EXPLAIN 명령은 EXPLAIN 뒤에 SELECT 문장을 적으면 된다.

```mysql
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM emplyoees e, salaries s
WHERE e.emp_no=s, emp_no
LIMIT 10;
```

EXPLAIN의 결과는 임시 테이블을 포함해 쿼리문에서 사용된 테이블 수 만큼 레코드로 보여준다. 





### id 칼럼

하나의 SELECT문은 하위 SELECT문을 포함할 수 있다. 이렇게 SELECT 단위로 구분한 것을 `단위 SELECT 쿼리`라고 한다. 실행 계획의 id 칼럼은 단위 SELECT 쿼리의 식별자이다.



### select_type 칼럼

SELECT 쿼리가 어떤 타입의 쿼리인지 표시하는 칼럼이다. 종류는 다음과 같다.

#### SIMPLE

UNION이나 서브쿼리를 포함하지 않는 단순한 SELECT문을 말한다. 일반적으로 가장 바깥의 SELECT문이 SIMPLE에 해당한다.

#### PRIMARY

UNION이나 서브쿼리를 포함한 SELECT문에서 가장 바깥에 있는 단위 SELECT 쿼리를 말한다.

#### UNION

UNION으로 결합하는 단위 SELECT 쿼리 중에서 두 번째 이후의 단위 SELECT 쿼리를 말한다.

#### DEPENDENT UNION

UNION으로 결합하는 쿼리 중에서 외부에서 정의된 테이블을 참조하는 단위 SELECT 쿼리를 말한다.

일반적으로 서브쿼리는 외부쿼리보다 먼저 실행된다. 하지만 DEPENDENT 키워드를 포함하는 서브쿼리는 외부쿼리에 의존적이기 때문에 외부쿼리보다 먼저 실행될 수 없다. 그래서 DEPENDENT 키워드가 포함된 쿼리는 비효율적인 경우가 많다.

#### UNION RESULT

`UNION ALL`이나 `UNION (DISTINCT)`쿼리를 통해 생성된 결과를 담아두는 임시 테이블을 말한다. 단위 SELECT 쿼리가 아니기 때문에 id값은 부여되지 않는다.

`<union1, 2>`는 id가 1인 단위 쿼리 결과와 id가 2인 단위 쿼리 결과를 UNION했다는 것을 의미한다.

#### SUBQUERY

일반적인 서브쿼리와 달리 FROM절 이외에서 사용되는 서브쿼리만을 말한다.

#### DEPENDENT SUBQUERY

서브쿼리가 외부 SELECT문에서 정의된 칼럼을 사용하는 경우를 말한다. 

```mysql
EXPLAIN
SELECT e.first_name,
	(SELECT COUNT(*)
    FROM dept_emp de, dept_manager dm
    WHERE dm.dept_no=de.dept_no AND de.emp_no=e.emp_no) AS cnt -- 내부에서 e 사용
FROM employees e -- 외부에서 e 정의
WHERE e.emp_no=10001;
```

외부에서 정의된 employee 테이블을 내부 SELECT 쿼리에서 사용하기 때문에 외부 SELECT 쿼리에 의존적이다. DEPENDENT UNION과 마찬가지로 외부 쿼리가 먼저 실행되야 하기 때문에 처리 속도가 느리다.

#### DERIVED

서브쿼리가 FROM절에서 사용된 경우 항상 DERIVED인 실행 계획을 만든다. 단위 SELECT 쿼리의 실행 결과를 메모리에 임시 테이블로 생성하는 것을 말한다. 이것을 파생 테이블이라고 하는데, 파생 테이블엔 인덱스가 없어서 대부분의 경우 MySQL은 파생 테이블을 최적화 하지 못한다.

```mysql
EXPLAIN
SELECT *
FROM
	(SELECT de.emp_no FROM dept_empde) tb,
	employees e
WHERE e.emp_no=tb.emp_no;
```

MySQL 6.0부터는 FROM절의 최적화가 개선되지만, 이전 버전에선 FROM절의 서브쿼리를 신경써서 튜닝해야 한다. 가능하다면 DERIVED형태의 실행 계획은 조인으로 해결하는 것이 좋다.

#### UNCACHEABLE SUBQUERY

쿼리문에서 똑같은 서브쿼리가 실행될 땐 캐싱해놓은 서브쿼리를 사용한다.

- SUBQUERY : 외부 쿼리에 영향을 받지 않기 때문에 프라이머리 테이블을 한 번만 실행해서 캐싱한다.
- DEPENDENT SUBQUERY : 외부 쿼리에 의존하기 때문에 프라이머리 테이블(외부 쿼리)을 레코드 단위로 캐싱한다.

UNCACHEABLE SUBQUERY는 서브쿼리에 포함된 요소에 의해 캐싱이 불가능한 경우를 말한다. 캐싱이 불가능한 경우는 다음과 같다.

- 사용자 변수가 서브쿼리에 사용된 경우
- NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
- `UUID()`나 `RAND()`같이 결과가 달라지는 함수가 서브쿼리에 사용된 경우

```mysql
EXPLAIN
SELECT *
FROM employees e
WHERE e.emp_no = (
	SELECT @status FROM dept_emp de WHERE de.dept_no='d005' -- 사용자 변수 사용
)
```

#### UNCACHEABLE UNION

캐싱할 수 없는 요소가 들어간 서브쿼리를 UNION 한 경우를 말한다.



### table 칼럼

MySQL의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블에 별칭을 부여한 경우 별칭으로 표시되고, 별도의 테이블을 사용하지 않은 SELECT문의 경우엔 NULL로 표시된다.

```mysql
EXPLAIN SELECT NOW(); -- 별도의 테이블 지정 X
EXPLAIN SELECT NOW() FROM DUAL; -- 호환을 위해 이렇게도 표현 가능
```

MySQL에선 FROM절을 생략해도 되지만 다른 DBMS에선 SELECT문이 FROM절을 반드시 포함해야 한다. 이런 경우 `FROM DUAL`이라고 하면 다른 DBMS와 호환이 가능하다. 또한 FROM절에 서브쿼리를 사용한다면 반드시 별칭을 부여해야 한다.

table 칼럼에 `<derived2>` 처럼 `<>`로 둘러싸인 것은 임시 테이블을 의미한다. 여기서 `2`는 단위 SELECT 쿼리의 id를 가리키며 어떤 단위 SELECT 쿼리에서 파생된 테이블인지를 의미한다.



### type 칼럼

실행계획에서 type을 포함해 이후로 나오는 칼럼은 테이블의 레코드를 어떤 방식으로 읽었는지를 말한다. type의 종류는 다음과 같다.(성능 순서)

- system
- const
- eq_ref
- ref
- fulltext
- ref_or_null
- unique_subquery
- index_subquery
- range
- index_merge
- index
- ALL

ALL은 풀 테이블 스캔을 의미하고 ALL을 제외한 나머지는 인덱스를 사용한 접근 방법이다. 하나의 단위 쿼리는 하나의 접근 방법만 사용할 수 있다.

#### system

테이블에 레코드가 없거나 1개만 존재할 때의 접근 방법을 말한다. InnoDB 테이블에선 나타나지 않고 MyISAM이나 MEMORY 테이블에서만 사용된다. InnoDB일 경우 ALL 또는 index로 표시된다.

#### const

테이블의 레코드 수와 상관 없이, 쿼리가 PK나 Unique키 칼럼을 이용하는 WHERE 조건절을 갖고 있으며 오직 1건 만을 반환하는 쿼리의 접근 방법을 말한다. PK나 Unique키가 복합키로 구성되어 있어서 일부 칼럼만 사용할 때는 1건만 반환하더라도 ref로 표시된다.

const인 실행 계획은 MySQL의 옵티마이저가 최적화할 때 상수화된 후 쿼리 실행기로 전달된다.

```mysql
EXPLAIN
SELECT * FROM employees WHERE emp_no=10001;
```

#### eq_ref

조인이 일어나는 실행 계획에서, 첫 번째로 읽은 테이블의 칼럼 값을 조인할 테이블의 검색 조건으로 사용할 때 두 번째 테이블의 접근 방법을 말한다. 두 번째 테이블은 반드시 1건의 레코드만 반환해야 한다.

복합키인 경우 모든 칼럼이 조건에 사용돼야 eq_ref 접근 방법이 사용될 수 있다.

```mysql
EXPLAIN
SELECT * FROM dept_emp de, employees e
WHERE e.emp_no=de.emp_no AND de.dept_no='d005'; -- 검색조건에 의해 두 번째 테이블인 e는 eq_ref타입
```

#### ref

조인의 순서와 인덱스 종류에 상관 없이 PK나 Unique키 칼럼을 이용하는 WHERE 조건절로 검색한 경우를 말한다.

반환 레코드가 항상 1건이라는 보장이 없어서 const와 eq_ref보단 느리지만 매우 빠른 방법 중 하나다. 따라서 쿼리를 튜닝할 때 const, eq_ref, ref 접근 방법에 대해선 크게 신경 쓰지 않아도 된다.

```mysql
EXPLAIN
SELECT * FROM dept_emp WHERE dept_no='d005';
```

#### fulltext

MySQL의 전문 검색 인덱스를 사용한 접근 방법을 말한다. 전문 검색은 `MATCH() AGAINST()` 구문을 말하는데, 반드시 전문 검색용 인덱스가 준비돼있어야 한다.

옵티마이저는 통계 정보를 기반으로 비용을 계산한다. 전문 검색 인덱스는 통계 정보가 관리되지 않기 때문에 전문 인덱스를 사용할 수 있다면 비용과 관계 없이 매번 fulltext 접근 방법을 사용한다.하지만 더 빠른 const, eq_ref, ref를 사용할 수 있다면 전문 검색을 사용하지 않는다.

```mysql
EXPLAIN
SELECT *
FROM employee_name
WHERE emp_no=10001
	AND emp_no BETWEEN 10001 AND 10005
AND MATCH(first_name, last_name) AGAINST('Facello' IN BOOLEAN MODE);
```

#### ref_or_null

이름 그대로 ref 접근 방법 또는 null 비교 접근 방법을 말한다. 실무에서 잘 사용하지 않는다.

#### unique_subquery

서브쿼리에서 중복되지 않은 값만 반환될 때 이 접근 방법을 사용한다. WHERE의 IN절을 위한 접근 방법이다.

```mysql
EXPLAIN
SELECT * FROM departments WHERE dept_no IN (
	SELECT dept_no FROM dept_emp WHERE emp_no=10001);
```

#### index_subquery

IN절의 경우 중복된 값이 먼저 제거되어야 한다. IN절의 서브쿼리가 중복된 값을 반환할 수 있지만 중복된 값을 인덱스를 통해 제거할 수 있을 때 이 접근 방법이 사용된다.

unique_subquery의 경우 중복된 값이 나오지 않기 때문에 중복 제거를 하지 않아도 된다.

#### range

range는 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 말한다. `<`, `>`, `IS NULL`, `BETWEEN`, `IN`, `LIKE`등의 연산자를 이용해 인덱스를 검색할 때 사용한다. 일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법으로 어느 정도의 성능이 보장된다.

```mysql
EXPlAIN
SELECT dept_no FROM dept_emp WHERE dept_no BETWEEN 'd001' AND 'd003';
```

일반적으로 const, ref, range를 모두 묶어서 인덱스 레인지 스캔이라고 한다.

#### index_merge

2개 이상의 인덱스를 이용해 각각 검색 결과를 만든 후 이를 병합하는 방법이다. 다음과 같은 특징이 있다.

- 여러 인덱스를 읽어야 하기 때문에 range보다 효율이 떨어진다.
- AND와 OR 연산이 복잡하게 연결된 쿼리에선 제대로 최적화하지 못할 때가 많다.
- fulltext를 사용하는 쿼리에선 적용되지 않는다.
- index_merge의 결과는 항상 2개 이상의 집합이기 때문에 교집합, 합집합과 같은 작업이 필요하다.

```mysql
EXPLAIN
SELECT * FROM employees
WHERE emp_no BETWEEN 10001 AND 11000
	OR first_name='Smith';
```

`emp_no BETWEEN 10001 AND 11000`조건은 employees 테이블의 PK를 이용해 조회하고 `first_name='Smith'`조건은 ix_firstname 인덱스를 이용해 조회해서 두 결과를 병합하는 식으로 처리한다.

#### index

index 접근 방법은 인덱스 풀 스캔을 말한다. range처럼 필요한 부분만 읽는 것이 아니다. 다음과 같은 경우 사용된다.

- const, ref, range와 같은 인덱스 레인지 스캔 방법으로 인덱스를 사용하지 못하는 경우이면서 인덱스에 있는 칼럼으로만 처리할 수 있는 경우(데이터 파일을 읽지 않아도 되는 경우)
- const, ref, range와 같은 인덱스 레인지 스캔 방법으로 인덱스를 사용하지 못하는 경우이면서 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우(별도로 정렬 작업을하지 않아도 되는 경우)

```mysql
EXPLAIN
SELECT * FROM departments ORDER BY dept_name DESC LIMIT 10;
```

#### ALL

ALL 접근방법은 풀 테이블 스캔을 말한다. 가장 비효율적인 방법이다. index와 ALL 접근 방법은 작업 범위를 제한하지 않기 때문에 웹서비스처럼 빠른 응답을 보여줘야 하는 OLTP 환경엔 적합하지 않다.

다른 DBMS처럼 InnoDB도 풀 테이블 스캔처럼 대량의 디스크 I/O를 유발하는 작업을 위해 한번에 많은 페이지를 읽는 기능을 제공하는데, 이것을 리드 어헤드(Read Ahead)라고 한다.

데이터웨어하우스나 배치 프로그램처럼 대용량의 레코드를 처리하는 쿼리에선 잘못 튜닝(억지로 인덱스 사용)된 쿼리보다 더 나을 수도 있다. 마냥 풀 테이블 스캔이나 인덱스 풀 스캔을 사용하지 않는 것은 아니다.