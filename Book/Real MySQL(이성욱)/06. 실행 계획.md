## 개요

### 쿼리 실행 절차

MySQL 서버에서 쿼리가 실행되는 과정은 크게 3가지이다.

1. 사용자의 SQL문을 MySQL 서버가 이해할 수 있는 수준으로 분리
2. SQL의 파스 트리를 이용해 어떤 테이블부터 읽고 어떤 인덱스를 사용해 테이블을 읽을지 선택
3. 2번째 단계에서 결정된 읽기 순서나 선택된 인덱스를 사용해 스토리지 엔진에서 데이터를 가져옴

1단계를 `SQL 파싱(Parsing)`이라고 하며 MySQL 서버의 SQL 파서라는 모듈로 처리한다. 문법 오류는 여기서 판별된다.

2단계에선 최적화 및 실행 계획 단계를 수립한다. `SQL 파스 트리`를 참조해 다음과 같은 처리를 한다.

- 불필요한 조건 제거 및 복잡한 연산 단순화
- 테이블에 조인이 있는 경우 테이블을 읽는 순서 결정
- 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
- 가져온 레코들을 임시 테이블에 넣고 다시 한번 가공해야하는지 결정

3단계에선 수립된 계획대로 스토리지 엔진에 레코드를 요청하고 MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬한다.



### 옵티마이저의 종류

옵티마이저는 데이터베이스 서버에서 두뇌에 해당된다. 옵티마이저의 종류는 크게 2가지다.

- 비용 기반 최적화(Cost-based optimizer, CBO) : 현재 대부분의 DMBS가 사용
- 규칙 기반 최적화(Rule-based optimizer, RBO) : 예전 오라클에서 사용

규칙 기반 최적화는 테이블의 레코드 수나 선택을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다.

비용 기반 최적화는 쿼리를 처리하는 여러가지 방법을 만들어놓고 비용과 통계 정보를 통해 비교해서 최소 비용의 방법으로 실행 계획을 수립한다.



### 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보다. 잘못 된 통계 정보 때문에 비효율적인 쿼리가 실행될 수도 있다.

MySQL도 비용 기반 최적화를 사용하지만 다른 DBMS보다 통계 정보가 다양하진 않다. MySQL의 통계 정보는 레코드 수와 인덱스의 유니크한 값 개수 정도다. MySQL에서 통계 정보는 동적으로 순간순간 자동으로 변경된다. 레코드 수가 많지 않으면 통계 정보가 부정확하기 때문에 `ANALYZE` 명령을 통해 통계 정보를 갱신해야 한다.

ANALYZE를 실행하는 동안 MyISAM 테이블은 읽기만 가능하고, InnoDB 테이블은 읽기와 쓰기 모두 불가능하다. MyISAM 테이블의 ANAYLZE는 인덱스 전체를 스캔해서 많은 시간이 소요되지만 InnoDB는 인덱스 페이지 8개를 랜덤으로 선택해서 분석해서 상대적으로 빠르다.

InnoDB의 통계 수집 페이지 수를 `innodb_stats_sample_pages` 파라미터로 지정할 수 있지만 InnoDB는 통계 정보를 자주 수집하기 때문에 페이지 수를 기본값 8개에서 2-3배를 넘지 않게 설정하는 것이 좋다.



## 실행 계획 분석

기본적인 실행 계획은 `EXPLAIN` 명령을 통해 확인할 수 있다. 상세한 실행 계획은 `EXPLAIN EXTENDS`나 `EXPLAIN PARTITIONS` 명령을 통해 확인할 수 있다.

EXPLAIN 명령은 EXPLAIN 뒤에 SELECT 문장을 적으면 된다.

```mysql
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM emplyoees e, salaries s
WHERE e.emp_no=s, emp_no
LIMIT 10;
```

EXPLAIN의 결과는 임시 테이블을 포함해 쿼리문에서 사용된 테이블 수 만큼 레코드로 보여준다. 





### id 칼럼

하나의 SELECT문은 하위 SELECT문을 포함할 수 있다. 이렇게 SELECT 단위로 구분한 것을 `단위 SELECT 쿼리`라고 한다. 실행 계획의 id 칼럼은 단위 SELECT 쿼리의 식별자이다.



### select_type 칼럼

SELECT 쿼리가 어떤 타입의 쿼리인지 표시하는 칼럼이다. 종류는 다음과 같다.

#### SIMPLE

UNION이나 서브쿼리를 포함하지 않는 단순한 SELECT문을 말한다. 일반적으로 가장 바깥의 SELECT문이 SIMPLE에 해당한다.

#### PRIMARY

UNION이나 서브쿼리를 포함한 SELECT문에서 가장 바깥에 있는 단위 SELECT 쿼리를 말한다.

#### UNION

UNION으로 결합하는 단위 SELECT 쿼리 중에서 두 번째 이후의 단위 SELECT 쿼리를 말한다.

#### DEPENDENT UNION

UNION으로 결합하는 쿼리 중에서 외부에서 정의된 테이블을 참조하는 단위 SELECT 쿼리를 말한다.

일반적으로 서브쿼리는 외부쿼리보다 먼저 실행된다. 하지만 DEPENDENT 키워드를 포함하는 서브쿼리는 외부쿼리에 의존적이기 때문에 외부쿼리보다 먼저 실행될 수 없다. 그래서 DEPENDENT 키워드가 포함된 쿼리는 비효율적인 경우가 많다.

#### UNION RESULT

`UNION ALL`이나 `UNION (DISTINCT)`쿼리를 통해 생성된 결과를 담아두는 임시 테이블을 말한다. 단위 SELECT 쿼리가 아니기 때문에 id값은 부여되지 않는다.

`<union1, 2>`는 id가 1인 단위 쿼리 결과와 id가 2인 단위 쿼리 결과를 UNION했다는 것을 의미한다.

#### SUBQUERY

일반적인 서브쿼리와 달리 FROM절 이외에서 사용되는 서브쿼리만을 말한다.

#### DEPENDENT SUBQUERY

서브쿼리가 외부 SELECT문에서 정의된 칼럼을 사용하는 경우를 말한다. 

```mysql
EXPLAIN
SELECT e.first_name,
	(SELECT COUNT(*)
    FROM dept_emp de, dept_manager dm
    WHERE dm.dept_no=de.dept_no AND de.emp_no=e.emp_no) AS cnt -- 내부에서 e 사용
FROM employees e -- 외부에서 e 정의
WHERE e.emp_no=10001;
```

외부에서 정의된 employee 테이블을 내부 SELECT 쿼리에서 사용하기 때문에 외부 SELECT 쿼리에 의존적이다. DEPENDENT UNION과 마찬가지로 외부 쿼리가 먼저 실행되야 하기 때문에 처리 속도가 느리다.

#### DERIVED

서브쿼리가 FROM절에서 사용된 경우 항상 DERIVED인 실행 계획을 만든다. 단위 SELECT 쿼리의 실행 결과를 메모리에 임시 테이블로 생성하는 것을 말한다. 이것을 파생 테이블이라고 하는데, 파생 테이블엔 인덱스가 없어서 대부분의 경우 MySQL은 파생 테이블을 최적화 하지 못한다.

```mysql
EXPLAIN
SELECT *
FROM
	(SELECT de.emp_no FROM dept_empde) tb,
	employees e
WHERE e.emp_no=tb.emp_no;
```

MySQL 6.0부터는 FROM절의 최적화가 개선되지만, 이전 버전에선 FROM절의 서브쿼리를 신경써서 튜닝해야 한다. 가능하다면 DERIVED형태의 실행 계획은 조인으로 해결하는 것이 좋다.

#### UNCACHEABLE SUBQUERY

쿼리문에서 똑같은 서브쿼리가 실행될 땐 캐싱해놓은 서브쿼리를 사용한다.

- SUBQUERY : 외부 쿼리에 영향을 받지 않기 때문에 프라이머리 테이블을 한 번만 실행해서 캐싱한다.
- DEPENDENT SUBQUERY : 외부 쿼리에 의존하기 때문에 프라이머리 테이블(외부 쿼리)을 레코드 단위로 캐싱한다.

UNCACHEABLE SUBQUERY는 서브쿼리에 포함된 요소에 의해 캐싱이 불가능한 경우를 말한다. 캐싱이 불가능한 경우는 다음과 같다.

- 사용자 변수가 서브쿼리에 사용된 경우
- NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
- `UUID()`나 `RAND()`같이 결과가 달라지는 함수가 서브쿼리에 사용된 경우

```mysql
EXPLAIN
SELECT *
FROM employees e
WHERE e.emp_no = (
	SELECT @status FROM dept_emp de WHERE de.dept_no='d005' -- 사용자 변수 사용
)
```

#### UNCACHEABLE UNION

캐싱할 수 없는 요소가 들어간 서브쿼리를 UNION 한 경우를 말한다.



### table 칼럼

MySQL의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블에 별칭을 부여한 경우 별칭으로 표시되고, 별도의 테이블을 사용하지 않은 SELECT문의 경우엔 NULL로 표시된다.

```mysql
EXPLAIN SELECT NOW(); -- 별도의 테이블 지정 X
EXPLAIN SELECT NOW() FROM DUAL; -- 호환을 위해 이렇게도 표현 가능
```

MySQL에선 FROM절을 생략해도 되지만 다른 DBMS에선 SELECT문이 FROM절을 반드시 포함해야 한다. 이런 경우 `FROM DUAL`이라고 하면 다른 DBMS와 호환이 가능하다.



table 칼럼에 `<derived2>` 처럼 `<>`로 둘러싸인 것은 임시 테이블을 의미한다. 여기서 숫자는 단위 SELECT 쿼리의 id를 가리키며 어떤 단위 SELECT 쿼리에서 파생된 테이블인지를 의미한다.