## 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

connect에서 애플리케이션 제어권이 돌아오면 데이터 송수신 동작에 들어간다. 이 동작은 write 모듈을 호출해서 송신 데이터를 프로토콜 스택에 전달하면서 시작한다.

프로토콜 스택은 받은 데이터를 버퍼에 저장하고 기다리다가 일정한 데이터가 모이면 송신한다. 작은 데이터를 여러번 보내는 것은 비효율적이기 때문이다. 여기서 일정한 데이터는 **MTU(Maximum Transmission Unit)**라는 매개변수로 판단한다. MTU는 한 패킷에 저장할 수 있는 데이터의 크기로 보통 이더넷에선 1500바이트이다. MTU엔 헤더가 포함되어 있어서 헤더를 제외한 것이 운반할 수 있는 데이터의 최대 길이인데 이것을 **MSS(Maximum Segment Size)**라고 한다.

- MTU = `IP 헤더 + TCP 헤더 + 데이터`의 최대 크기
- MSS = `데이터`의 최대 크기

또한 데이터를 모으느냐고 송신이 지연되면 안되기 때문에 프로토콜 내부에 있는 타이머를 통해 일정 시간이 지나면 데이터를 송신한다. 이러한 MTU와 시간값은 OS의 종류나 버전에 따라 달라진다.



## 데이터가 클 때는 분할하여 보낸다

블로그나 게시판 글처럼 MSS의 길이보다 데이터가 클 경우 기다리지 않고 차례대로 MSS 크기 만큼 분할해서 송신한다. 이때 분할한 데이터에 TCP 헤더를 붙이고 IP 담당 부분에 건네줘서 송신한다.



## ACK 번호를 사용하여 패킷이 도착했는지 확인한다

TCP에는 송신한 패킷이 올바르게 도착했는지 확인하고, 도착하지 않았으면 다시 송신하는 기능이 잇다.

TCP 담당 부분은 데이터를 분할할 때 조각이 통신 시작부터 몇 번째 바이트인지 TCP 헤더에 기록한다. 이것을 **시퀀스 번호**라고 한다. 그리고 수신측은 패킷의 길이에서 헤더의 길이를 빼서 데이터의 크기를 계산할 수 있다. 시퀀스번호와 데이터 크기를 통해 받은 데이터가 어디서 시작됐고 얼마만큼 왔는지 파악할 수 있다. 이런 방법으로 수신측에서 패킷이 누락됐는지 확인할 수 있다. 수신측은 누락됐는지 확인하면서 몇번째 바이트까지 수신했는지 계산하고 TCP 헤더에 기록해 송신측으로 응답하는데, 이것을 **ACK 번호**라고 한다. 이렇게 ACK 번호를 송신측으로 보내는 동작을 **수신 확인 응답**이라고 하고, 송신측은 이를 통해 수신측이 어디까지 수신했는지 파악할 수 있다.

시퀀스 번호가 항상 1부터 시작하면 악의적인 공격을 받을 수 있기 때문에 난수를 통해 산출한 값으로 시작한다. 이 초기값은 최초로 SYN을 보낼 때 함께 보낸다.

실제 움직임 순서는 다음과 같다.

1. 클라이언트는 시퀀스 번호의 초기값을 산출해서 서버에 송신
2. 서버는 초기값을 통해 ACK 번호와 시퀀스 번호의 초기값을 산출해서 클라이언트에 송신
3. 클라이언트도 초기값을 통해 ACK 번호를 산출해서 서버에 송신

여기까지가 접속 동작이다. 데이터 송수신 동작의 순서는 다음과 같다.

1. 클라이언트는 시퀀스 번호와 데이터 송신
2. 서버는 ACK 번호 송신
3. 서버는 시퀀스 번호와 데이터 송신
4. 클라이언트는 ACK 번호 송신

 TCP는 이런 과정으로 상대가 데이터를 확인할 때까지 송신한 패킷을 버퍼에 보관해뒀다가 ACK 번호가 돌아오지 않으면 패킷을 다시 보낸다. 이를 통해 네트워크에서 오류가 발생하더라도 패킷을 다시 보내기 때문에 오류를 검출하고 회복 조치할 필요가 없다.

이 때문에 LAN 어댑터, 버퍼, 라우터 모두 회복 조치를 하지 않는다. 하지만 케이블이 분리되거나 서버가 다운돼서 데이터가 도착하지 않는 경우 데이터 송신 동작을 강제 종료하고 애플리케이션에 오류를 통지한다.



## 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다

ACK 번호가 돌아오는 것을 기다리는 시간을 **타임아웃 값**이라고 한다. 네트워크에 정체가 일어나면 지연될 수 있기 때문에 대기 시간을 어느 정도 길게 설정해야 한다.

하지만 서버가 멀 수도 있고, 인터넷이 혼잡할 수도 있기 때문에 일정한 값으로 정할 수 없다. 따라서 ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단한다.



## 윈도우 제어 방식으로 ACK 번호를 관리한다

ACK 번호가 돌아올 때까지 기다리는 것은 낭비이기 때문에 TCP는 윈도우 제어 방식을 사용한다. 윈도우 제어는 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 연속해서 여러 개의 패킷을 보내는 방법이다.

하지만 이렇게 하면 수신측의 능력을 초과해서 패킷을 보내는 일이 일어날 수도 있다. 즉, 버퍼에 보관하고 ACK 번호를 계산해서 응답하는데, 그 동안 버퍼가 넘쳐 데이터가 사라질 수 있다. 그래서 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고 수신측은 이 양을 초과하지 않도록 송신하는데, 이것이 윈도우 제어 방식의 개념이다.

수신측은 버퍼에 빈 부분이 생기면 그 분량 만큼을 TCP 헤더의 **윈도우 필드**를 통해 송신측에 알린다. 또한 수신 가능한 데이터 양의 최대값을 **윈도우 사이즈**라고 한다.



## ACK 번호와 윈도우를 합승한다

수신측에서 데이터를 받아 버퍼에 보관하면 수신측은 송신측에게 윈도우를 하나하나 통지하지 않아도 된다. 왜냐면 송신측이 보낸 만큼 빼서 스스로 산출할 수 있기 때문이다. 윈도우 통지가 필요할 때는 수신측이 수신 버퍼에서 애플리케이션으로 데이터를 전달했을 때이다. 이때 버퍼의 빈 영역이 생기기 때문이다.

ACK 번호는 수신측에서 데이터를 받았을 때 송신측에 보낸다.

윈도우와 ACK 번호를 조합해보면, 데이터가 수신 측에 도착해서 정상적으로 동작이 완료 되었을때 ACK 번호를 통지하고, 잠시 후 데이터를 버퍼에서 애플리케이션으로 전달했을 때 윈도우를 통지한다. 하지만 이렇게 따로따로 송신측에 보내면 효율이 떨어진다. 따라서 수신측은 기다렸다가 ACK 번호와 윈도우를 묶어서 보낸다. 이렇게해서 보내는 패킷의 수를 줄일 수 있다.

또한 ACK 번호와 윈도우는 연속해서 일어나면 최종적인 값만 통지하면 된다. 따라서 연속된 경우 중간의 것은 생략해서 보내는 패킷의 수를 줄일 수 있다.



## HTTP 응답 메시지를 수신한다

브라우저의 의뢰를 받아 프로토콜 스택이 HTTP 요청 메시지를 보내는 동작은 이렇게 끝이다. 이후 브라우저는 기다렸다가 웹 서버에서 오는 응답 메시지를 수신한다.

응답 메시지를 받기 위해 read 모듈을 호출한다. 그러면 프로토콜 스택에 제어권이 넘어간다. 프로토콜 스택은 수신 버퍼에서 수신한 데이터를 추출해 애플리케이션에게 전달한다. 만약 수신 버퍼에 수신한 데이터가 없다면 잠시 보류한다. 그리고 데이터가 도착하면 다시 작업을 재개한다.

먼저 수신한 데이터와 TCP 헤더의 내용을 통해 데이터가 누락되었는지 확인하고 문제가 없으면 ACK 번호를 반송한다. 이후 데이터 조각을 버퍼에 임시 보관한 뒤 조각들을 연결해 복원해서 애플리케이션에 전달한다. 애플리케이션에 제어권과 데이터를 전달하고 윈도우를 송신측에게 통지한다. 이 경우에도 ACK 번호와 윈도우는 묶어서 보낼 수도 있다.

