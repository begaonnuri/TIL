## 데이터 보내기를 완료했을 때 연결을 끊는다

애플리케이션이 데이터 송수신을 완료하면 연결을 끊기로 들어간다. 이때 어디서 데이터 송수신이 끝나는지는 애플리케이션에 따라 다르다. 웹은 서버에서 응답 메시지를 반송 완료한 경우 서버측에서 연결 끊기 단계에 들어간다(HTTP 1.0). 어떤 애플리케이션은 클라이언트측에서 먼저 연결 끊기 단계에 들어간다. 프로토콜 스택에선 양쪽 어디든 상관 없도록 만들어져 있다.

연결 끊기 단계에선 Socket 라이브러리의 close 모듈을 호출한다. 서버측으로 예를 들면, 서버측의 프로토콜 스택이 TCP 헤더를 만들고 연결 끊기를 나타내는 정보를 설정한다. 컨트롤 비트의 FIN 비트에 1을 설정하고 IP 담당 부분에 의뢰해서 클라이언트에 송신한다.

클라이언트는 FIN에 1이 설정된 TCP 헤더가 도착하면 소켓에 서버측에서 연결 끊기 동작에 들어갔다는 것을 기록하고 ACK을 서버측에 반송한다. 그 다음 애플리케이션이 read 모듈을 호출하면 데이터 대신 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 애플리케이션에게 알린다.

클라이언트측 애플리케이션도 close 모듈을 호출하고 FIN 비트에 1을 설정한 TCP 헤더를 만들어서 서버측에 송신한다.

이후 서버측에서 ACK 번호가 돌아오면 연결이 종료된다.



## 소켓을 말소한다

연결이 종료되면 소켓이 필요 없게 된다. 하지만 소켓을 바로 말소하지 않고 잠시 기다린 후 말소한다.

FIN을 보내고 ACK이 돌아오지 않는 경우 다시 한번 FIN을 보낸다. 이런 경우에 수신측의 소켓이 말소되면 소켓에 기록되어있는 제어 정보와 포트 번호도 알 수 없다. 이 시점에 다른 애플리케이션이 소켓을 작성하면 새로운 소켓에 말소했던 포트 번호가 할당될 수도 있다. 이 경우 말소되기 전의 소켓에게 보낸 FIN이 새로운 소켓에 도착해서 연결을 끊어버릴 수도 있다. 이런 오동작을 막기 위해 잠시 기다리는 것이다.



## 데이터 송수신 동작을 정리한다

이렇게 TCP 프로토콜에서 데이터를 송수신하는 동작이 끝났다. 전체 과정은 다음과 같다.

### 접속 대기 상태

1.  서버측에서 애플리케이션이 동작하기 시작했을 때 소켓을 만들고 접속 대기 상태로 만든다.

### 접속 동작

1. 클라이언트는 SYN을 1로 설정한 TCP 헤더를 만들어 서버에 보낸다. 이 TCP 헤더엔 시퀀스 번호의 초기값과 윈도우의 값도 기록되어 있다.
2. 서버에 도착하면 서버는 SYN을 1로 설정한 TCP 헤더를 보낸다. 이 TCP 헤더에도 시퀀스 번호와 윈도우의 값과 더불어 클라이언트의 TCP 헤더를 받았다는 것을 나타내는 ACK 번호도 기록되어 있다.

### 데이터 송수신 단계

1. 웹의 경우 클라이언트에서 서버로 리퀘스트 메시지를 보낸다. TCP는 적당한 크기의 조각으로 분할하고 TCP 헤더를 붙여 서버에 보낸다.
2. 서버는 ACK 번호를 클라이언트에 반송한다. 이때 최초의 데이터 조각인 경우 그냥 받지만, 송수신을 진행하면서 수신 버퍼에 빈 영역이 생기면 윈도우의 값을 함께 기록해 클라이언트에 보낸다.
3. 서버가 응답 메시지를 반송하면 클라이언트에서 1,2 동작이 동일하게 일어난다.

### 연결 끊기 동작

1. 웹의 경우 서버에서 연결 끊기 동작에 들어간다. 서버는 FIN을 1로 설정한 TCP 헤더를 클라이언트로 보낸다.
2. 클라이언트는 받았다는 것을 나타내는 ACK 번호의 TCP 헤더를 서버로 보낸다.
3. 이후 클라이언트도 FIN을 1로 설정한 TCP 헤더를 서버로 보낸다.
4. 서버는 받았다는 것을 나타내는 ACK 번호의 TCP 헤더를 클라이언트로 보내고 잠시 후 소켓이 말소된다.