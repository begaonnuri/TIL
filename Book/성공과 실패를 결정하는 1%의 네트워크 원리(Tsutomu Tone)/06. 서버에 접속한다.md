## 접속의 의미

소켓을 만들면 애플리케이션은 connect 모듈을 호출한다. 그러면 프로토콜 스택은 서버측 소켓에 접속한다.

이더넷이나 통신 회선은 항상 케이블이 연결되어 있기 때문에 데이터를 신호로 변환해서 송신하기만 하면 언제든 통신할 수 있다. 그러기 위해 통신 상대와의 사이에서 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만들어야 한다.

소켓을 만든 직후는 통신 상대가 누구인지 모른다. IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데 이것이 접속 동작의 역할이다.

서버측 또한 소켓을 만드는 동작만으로 상대를 알 수 없다. 게다가 서버측은 애플리케이션에서도 상대를 알 수 없다. 그래서 클라이언트는 본인의 IP 주소와 포트 번호를 서버측에 전달한다. 이처럼 클라이언트 측에서 서버측에 통신 동작의 개시를 전달하는 것도 접속 동작의 역할이다.

접속 동작을 실행하면 필요한 정보가 전달되고 데이터를 송수신할 수 있는 상태가 된다. 데이터를 송수신할 때는 데이터를 일시적으로 저장하는 메모리 영역이 필요한데, 이 영역을 버퍼 메모리라고 한다. 버퍼 메모리 확보도 접속한다는 동작의 의미이다.



## 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

제어 정보는 접속 동작 뿐만 아니라 데이터 송수신 동작과 연결 종료 동작을 포함해서 통신 동작 전체에서 필요한 정보를 TCP 프로토콜의 사양으로 규정한다. 이것을 **TCP 헤더**라고 한다. 클라이언트와 서버는 헤더에 필요한 정보를 기록해서 통신 동작을 진행한다.

제어 정보엔 프로토콜 스택의 동작을 제어하기 위해 소켓에 기록하는 정보도 있다. 여기엔 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등이 기록된다. 소켓의 제어 정보는 프로토콜 스택을 만드는 사람(OS)에 따라 달라진다. 중요한 항목을 제외하면 OS에 따라 다르다. 그래도 통신이 되는 이유는 통신할 때 헤더에 있는 제어 정보를 이용하기 때문이다.

즉, 통신 동작에 이용하는 제어 정보는 2가지다.

1. 헤더 정보
2. 소켓(프로토콜 스택의 메모리 영역)에 기록되는 정보



## 접속 동작의 실제

접속 동작을 추적해보면,

1. 애플리케이션이 Socket 라이브러리의 connect 모듈을 호출
2. 서버측 IP 주소와 포트 번호가 TCP 담당 부분에 전달
3. 서버의 TCP 담당 부분과 제어 정보 교환

4. 송신처와 수신처의 포트 번호를 통해서 클라이언트측 소켓과 서버측 소켓을 지정
5. 그리고 컨트롤 비트인 SYN을 1로 만든다. 이외에도 시퀀스 번호, 윈도우에 적정 값을 설정해서 TCP 헤더 생성
6. IP 담당 부분에 송신하도록 의뢰
7. IP 담당 부분이 패킷을 송신해 네트워크를 통해 서버에 도착하면 서버측 IP 담당 부분이 TCP 담당 부분에게 전달
8. 서버측 TCP 담당 부분이 TCP 헤더에 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 탐색
9. 찾은 소켓에 필요한 정보를 기록하고 접속 동작을 진행중 상태로 설정
10. 서버측 TCP 담당 부분은 응답을 전송



서버측도 송신처와 수신처의 포트번호와 SYN 비트를 설정한 TCP 헤더를 만든다. 응답을 돌려보내는 경우 패킷 도착을 확인하는 용도로 ACK 컨트롤 비트를 1로 만든다. 그리고 TCP 헤더를 IP 담당 부분에 전달해 클라이언트에 반송하는것을 의뢰한다.

패킷이 클라이언트에 도착하면 IP 담당 부분을 거쳐 TCP 담당 부분에 도착한다. TCP 헤더에서 SYN이 1이면 접속 성공으로 소켓에 서버의 IP 주소, 포트 번호와 함께 접속 완료를 나타내는 제어 정보를 기록한다. 그리고 패킷이 도착한 것을 서버에 알리기 위해 ACK 비트를 1로 만들어서 TCP 헤더를 반송한다. 이것이 서버에 도착하면 접속 동작이 종료된다.

이후 데이터를 송수신할 수 있는 상태가 되는데 이것을 **커넥션**이라고 한다. 커넥션은 close를 호출하여 연결을 끊을 때까지 계속 존재한다.