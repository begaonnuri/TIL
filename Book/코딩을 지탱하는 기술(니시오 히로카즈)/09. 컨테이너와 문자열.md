## 다양한 종류의 컨테이너

언어에 따라 다양한 특성을 가진 컨테이너가 사용된다. 예를 들어 C언어의 배열, LISP의 리스트, Python의 튜플, Ruby의 Array등이 그렇다. 또한 같은 용어라도 언어에 따라 다르게 사용된다. 예를 들어 LISP와 Haskell의 리스트는 Java와 Python의 리스트와 내부구조가 완전히 다르다.



## 왜 다양한 컨테이너가 존재할까?

다양한 컨테이너가 존재하는 이유는 각각의 컨테이너마다 장단점이 있기 때문이다. 컨테이너에 넣은 데이터는 메모리에 저장된다. 컨테이너의 종류마다 메모리 저장 방법이 다르기 때문에 컨테이너마다 장단점이 생기게 된다.



### 배열과 연결 리스트

배열에는 값만 들어있지만 연결 리스트엔 '다음 값이 어디에 있는지'의 정보도 들어있다.

연결 리스트가 메모리를 2배 사용하는 것 처럼 보이지만 요소를 삽입하는 시간이 빠르다. 배열에선 값을 순서대로 저장하기 때문에 요소를 삽입할 때 삽입된 위치보다 뒤에 있는 요소를 전부 다른 위치로 이동시켜야 한다.

반면 연결 리스트에선 메모리에 순서대로 저장할 필요가 없다. 다음 요소의 위치를 저장해두기 때문이다.

요소의 개수가 많아지면 배열은 점점 처리 시가닝 늘어나기 때문에 요소가 많고 삽입이 자주 발생하는 경우엔 연결리스트를 사용하는 것이 좋다.



### 연결 리스트의 장단점

연결 리스트의 장점은 삽입, 삭제시 O(1)의 복잡도를 갖는다는 것이다. 반면 배열에선 삽입, 삭제시 해당 요소 뒤에 있는 요소를 전부 이동해야 하기 때문에 O(n)이다.

하지만 연결 리스트에도 단점이 있다. 'n항목에 있는 요소는 무엇인가?'를 알기 위해 시간이 걸린다는 것이다. 배열에선 순서대로 저장하기 때문에 금방 n번째 요소를 알 수 있다. 반면 연결 리스트의 n번째 요소를 알고 싶으면 요소를 읽어 가며 다음 데이터의 위치를 확인해나가야 한다. 이 과정은 O(n)이다.



### 언어에 따른 차이

Java, Python, Ruby등 대부분의 언어에서는 배열이 가장 기본적인 컨테이너로 제공되고 있다. 반면 LISP나 Haskell 등의 언어에서는 연결 리스트가 가장 기본적인 컨테이너로 제공되고 있다.



## 사전, 해쉬, 연상 배열

사전, 해쉬, 연상 배열은 많은 언어들이 지원하고 있는 컨테이너이다. 배열은 'n번째의 값' 처럼 정수와 값을 대응시킨 것이다. 사전은 '"age"의 값' 처럼 문자열과 값을 대응시킨 것이다. 여기서 문자열을 키(key)라고 부른다.

'값을 여러 개 넣는다'를 구현한 방법으로 배열과 연결리스트가 있듯이, '문자열과 값의 대응을 여러 개 넣는다'를 구현한 방법으로 해쉬 테이블과 트리가 있다.



### 해쉬 테이블

해쉬 테이블은 문자열을 인수로 받아서 정수를 반환하는 해쉬 함수를 사용해서 문자열과 값의 대응 관계를 표현하는 방법이다. 해쉬 함수를 사용해 문자열을 정수 n으로 변환하고 배열의 n번째 위치에 저장한다.



### 트리

연결 리스트에선 다음 요소에 대한 정보를 같이 저장했었지만 트리에선 왼쪽 요소, 오른쪽 요소에 대한 정보를 저장한다. 트리에 값을 저장할 때 기본적인 규칙은 Key가 작으면 왼쪽에, 크면 오른쪽에 저장하는 것이다. 값을 꺼낼 때도 같은 방법으로 비교해 나간다.



### 요소를 꺼내는 시간

이런 복잡한 방법을 쓰지 않고 '배열을 두 개 쓰거나 배열에 키, 값, 키, 값 형태로 넣으면 되지 않나'라고 생각할 수도 있다. 이 경우 키에 대응하는 값을 찾아야 하기 때문에 O(n)이다. 요소의 개수가 적으면 상관 없지만 많아질 경우 적절하지 않다.

트리의 경우 높이가 하나 증가하면 요소의 수가 2배가 된다. 데이터가 2배가 될 때마다 비교 횟수는 1회 증가한다. 따라서 O(log n)이다.

해쉬 테이블의 경우 키에 대응하는 값을 꺼내기 위해서 '키를 함수로 변환'하고 '해당 장소에 있는 값을 읽는' 작업이 필요하다. 이 작업은 데이터 개수와 관계 없기 때문에 O(1)이다. 하지만 해쉬 테이블은  값을 넣기 위해 큰 배열을 사용하고 있기 때문에 메모리 소비량이 매우 크다.



### 만능 컨테이너란 없다

항상 좋은 컨테이너는 없다. 어떤 사용법을 적용할 것인가, 어떤 조작이 많은가, 메모리 절약이 필요한가, 계산 시간을 줄여야 하는가 등 컨테이너를 사용하는 목적에 맞게 사용해야 한다. 

0.01초의 처리를 0.005초로 줄여도 사용자의 만족도는 그리 높아지지 않는다. 하지만 데이터 10만건의 처리가 100초가 걸린다면 사용자는 만족하지 않을 것이고, 이 때 고속화가 필요한 것이다.



## 문자란?

### 문자 집합과 문자 부호화 방식

문자란 인간이 '문자라고 부르자'라고 정한 기호 집합에 불과하다. 문자 집합은 나라나 문화에 따라 다르다.

한편 문자 집합을 디지털 데이터로 표현하려면 부호화를 해야한다. 부호화 방법은 '효율이나 개인적 필요를 위해 부호화 방법을 만드는 것'과 '표준화를 하는것'에 대한 의견 차이가 있어왔다.



### EDSAC 문자 코드

EDSAC은 한 문자에 5비트를 사용했고, 하나의 열에 5개 구멍을 뚫은 종이 테이프를 입력에 사용했다. 그리고 숫자, 문자, 시프트를 사용해서 출력했다.



### ASCII와 EBCDIC 시대

EDSAC 이후 다양한 컴퓨터가 만들어졌꼬 문자 부호화 방식도 제각각이었다. 다른 컴퓨터에서 읽으려면 매번 변환 작업이 필요했고, 문자 부호화 방법을 표준화하자는 움직임이 일어났다. 그래서 나온 것이 ASCII이다. ASCII는 American Standard Code for Information Interchange의 약자로 정보 교환을 위환 미국 표준 부호를 의미한다.

ASCII는 한 문자당 7비트를 사용하는 부호화 방식이다. 7비트로 128개의 문자를 표현할 수 있기 때문에 시프트로 변환할 필요가 없어졌다. 하지만 당시 컴퓨터 시장을 장악하고있던 IBM이 8비트 부호화 방법인 EBCDIC를 공개해서 부호화 방법을 통일하자는 이상은 실현되지 않았다.



### Unicode에 의한 통일

인터넷이 발전하고 다양한 나라에서 만들어진 데이터가 교환되기 시작하면서 각 나라의 부호화 방법을 이해해야 했다. 그래서 전 세계의 문자를 부호화하는 방법을 만들자는 움직임이 생겼고 국제 표준화 기구인 ISO에서 UCS(Universal Character Set) 표준화 작업을 시작했다. 이렇게 전 세계 문자를 포함한 문자 집합인 Unicode가 탄생했다.

한국어 문자열을 부호화 하는 방법으로 UTF-8이 있다. UTF-8은 Unicode와 같이 통일된 문자를 부호화하는 방법이다.



## 문자열이란?

### 길이 정보를 갖고있는 Pascal, 갖고 있지 않은 C언어

C언어와 Pascal은 둘 다 하나의 문자를 8비트로 정의하고 있다. Pascal 문자열은 제일 앞에 문자열 길이를 기록해둔다는 규칙을 채용하고 있다. 하지만 C언어는 어디까지가 문자열인지 알 수 없다.

C언어에선 문자의 끝을 표현하는 특별한 문자를 사용한다. 바로 NUL이다. NUL은 0에 대응하는 문자로 C언어에선 \0으로 표현한다. C언어 문자열은 원시적이기 때문에 특이한 현상을 발생시킬 수도 있다.

```c
int main(){
    char str[3] = "abc";
}
```

abc라는 문자열을 담기 위해선 문자 3개와 NUL을 포함한 문자 4개의 영역이 필요하다. 읽을 수 없는 메모리 영역을 침범한 경우 프로그램이 종료될 수도 있다.



### 한 문자가 16비트인 Java 문자열

C언어 방식의 문자열은 다루기가 어려워서 대부분의 언어는 Pascal 방식의 문자열을 채택하고 있다. Java 문자열도 길이 정보를 갖고있지만 char 형이 16비트로 정해져 있다는 것이 다르다. 문자에 대한 정의가 다른것이다. C언어에서 문자란 8비트로 표현할 수 있는 ASCII 또는 EBCDIC의 문자지만 Java에서 문자란 16비트로 표현할 수 있는 Unicode의 문자인 것이다.



### Python 3에서 이루어진 설계 변경

Python은 Java와 같이 16비트 문자열인 Unicode와 Pascal과 같은 8비트 문자열을 모두 지원한다. Python 2에선 "아"라고 쓰면 UTF-8인 경우 3바이트인 ['0xe3', '0x81', 'ox82']가 되지만, u"아"라고 쓰면 Unicode 문자열이 되어 ['0x3042']가 된다.

하지만 이 설계는 ASCII 문자만 사용할 땐 정상 동작하지만 ASCII 이외의 문자를 사용하는 나라에선 문제가 발생한다. 그래서 Python 3부터 "아"라고 쓰면 Unicode문자열이 되고 b"아"라고 쓰면 바이트열이 되도록 변경했다.



## 정리

어떻게 메모리에 저장하느냐에 따라 성능 차이가 난다는 것과 각각의 저장 방법에 장단점이 있다는 것을 배웠다. 또한 문자열과 값을 대응시키는 것에 대해서도 배웠다.

문자들이 들어있는 문자열에 대해서도 배웠다. 무엇이 문자인지에 대한 문자 집합의 차이에 대해서 배웠고, 어떻게 문자를 비트열로 표현하는지에 대한 문자 부호화 방식의 차이에 대해서도 배웠다. 그리고 어떤 정보를 어떤 메모리에 저장하는지에 대한 문자열 구현의 차이에 대해서도 배웠다.