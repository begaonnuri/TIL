## 형이란?

형은 사람이 데이터에 붙인 '추가 데이터'이다. 컴퓨터의 데이터는 0과 1의 집합(비트열)으로 표현되어 있다. 같은 비트열도 어떻게 해석할지에 따라 틀린 값이 될 수 있다. 이를 피하기 위해 ''어떤 종류의 값인지'에 대한 정보를 추가한 것이 형의 시작이다.



## 수치를 On과 Off로 표현하는 방법

가장 간단한 방법은 3개의 램프를 두는 것이다. 하지만 이 방법은 표현하고 싶은 수만큼의 램프가 필요하다.



### 자릿수 발명

컴퓨터가 탄생하기 훨씬 전부터 인류는 자릿수 기수법을 발명했다. 10진수를 사용하면 27개의 램프 만으로 0부터 999까지 표현할 수 있다. 자릿수를 사용함으로써 필요한 램프를 999개에서 27개로 줄인 것이다. 더 줄일 순 없을까?



### 7세그먼트 디스플레이

컴퓨터가 탄생하기 전 하나의 자리를 7개의 램프로 표현할 수 있는 방법이 발명되었다. 계산기 등에서 수치를 표현하기 위해 사용되는 7세그먼트 디스플레이다. 7세그먼트 디스플레이를 사용하면 7개의 램프로 한 자릿수를 표현할 수 있다.



## 한 자리에 필요한 램프는 몇 개일까?

가장 램프를 적게 사용할 수 있는 방법은 무엇일까? 하나의 램프로 2가지 부호를 표현할 수 있다. 램프가 4개 있으면 16가지 부호를 표현할 수 있다. 실제로 UNIVAC I 등 초기 컴퓨터는 4개의 On/Off를 사용해 수치를 표현했다. 이를 Excess-3이라고 부른다.



### 10진수에서 2진수로

램프 4개로 16가지를 표현할 수 있음에도 10가지만 사용하고 있었기 때문에 간격을 채워 넣을 방법이 필요했다. 이 간격은 한 자리에 10가지 기호를 사용하고 있는 것이 원인이다. 램프 하나로 2가지 상태를 표현할 수 있기 때문에 자릿수 또한 2자리로 맞추는 발상으로 2진수가 사용됐다. 2진수를 사용해 효율적으로 수를 표현할 수 있었다.

초기 컴퓨터에선 8개의 램프(8비트의 CPU)를 사용했다. 현재 개인용 컴퓨터에선 32개나 64개의 램프를 사용하는 것이 대부분이다.



### 8진수와 16진수

2진수에서는 사용하는 기호의 종류가 적어진 대신 많은 문자가 필요하다. 1000을 2진수로 표현하면 1111101000처럼 너무 길어서 사람이 읽기 어렵다. 그래서 2진수 문자 몇개를 모아서 하나의 문자로 표현한 것이 8진수와 16진수이다. 1111101000은 8진수로 01750이고, 16진수로 0x3e8이 된다. 8진수의 앞엔 0 또는 0o를, 16진수의 앞엔 0x를 붙이는 경우가 많다.



## 실수는 어떻게 표현할까?



### 고정 소수점

한 가지 방법은 소수점을 어디에 붙일지 정하는 것이다. 예를 들어 소수점을 4자리 이동시켜서 소수점 이하 4자리를 소수부라고 정하면 1이 0.0001이 되고, 100이 0.0100, 즉 0.01이 된다.

이 방법은 0.0001보다 작은 값을 표현할 수 없는 문제가 있다. 5자리를 소수부로 정하는 방식으로 규칙을 변경할 수도 있지만 실수할 여지가 많다.



### 부동 소수점

사람이 기억하기 어렵다는 문제는 컴퓨터가 기억하는 구조를 만들어서 해결할 수 있다. 어디부터 소수부인지 값에 포함해서 해결한다. 부동 소수점에도 여러 가지 규칙이 많았지만 현재는 표준화되어 IEEE754가 적용되고 있다.



#### IEEE 754에서 정의하고 있는 부동 소수점 구조 

최상위 비트는 수의 부호를 표현한다. 0이면 양수, 1이면 음수라는 의미이다. 다음 8개의 비트가 자릿수를 표현하는 지수부다. 8개의 비트로 -127~128의 범위를 표현할 수 있다. -126은 소수점을 왼쪽으로 126자리 움직이는 것을 의미하고 127은 소수점을 오른쪽으로 127자리 움직이는 것을 의미한다. 나머지 23개의 비트가 소수점 이하를 표현하는 가수부다.



대부분의 언어에서 실수를 부동 소수점으로 표현한다. 하지만 부동 소수점의 방법으론 3/10을 표현할 수 없다. 10진수로 0.3이지만 2진수의 경우 0.010011001100..으로 무한소수가 되어버린다. 은행처럼 돈을 다루는 분야에선 고정 소수점이나 Excess-3과 같은 10진수 계산법이 사용되고 있다.



## 형은 무엇을 위해 존재할까?

컴퓨터는 비트열만으로 정수로 해석해야 할지 부동 소수점으로 해석해야 할지 알 수 없다. 값이 어떤 종류인지에 대한 정보가 필요한데, 이것이 형이다.



### 형이 없을 때 발생하는 문제

형이 없다면 예상한 값과 전혀 다른 값이 나온다. 예를들어 부동 소수점 3.0과 7.0을 정수 형태로 더하면 10.0이 아닌 매우 큰 정수 값이 나온다.



### 초기 FORTRAN의 형

한 가지 방법은 변수명 안에 든 것을 표현하기 위한 규칙을 만드는 것이다. 초기 FORTRAN에선 변수명 선두 글자가 I~N이면 정수, 그 이외이면 부동 소수점이 들어있다는 규칙을 사용했다.



### 언어 처리계에 변수 종류를 알린다

다른 방법은 언어 처리계에 정수 변수라고 알려 컴퓨터가 기억해두는 것이다. 이것이 변수형 선언이 탄생한 이유다. 예를 들어 C언어에선 `int x`로 x가 가리키고 있는 메모리 영역은 정수로 해석한다. 형 정보가 주어짐으로써 어떻게 해석할 지 알 수 있게 된다.



### 암묵의 형 승격

`x + y`를 할 때 한 쪽이 정수이고 한 쪽이 부동 소수점인 경우 초기 FORTRAN에선 에러 처리를 했다. 프로그래머가 명시적으로 함수를 사용해 변환했다. C언어에선 정수를 부동 소수점으로 암묵적 변환을 시킨다.

하지만 `x / 2`를 할 때 x가 정수이면 나눗셈을 한 후 소수점 이하를 버린다. 하지만 x가 부동 소수점이면 나눗셈을 하고 부동 소수점이 표현할 수 있는 수치로 다듬는다. 프로그래머는 x가 어떤 형인지 기억해야 하는데, 이것은 형이 존재하는 이유에 역행하는 것이다.

C언어는 '소수점 이하를 버릴지 버리지 않을지는 계산 대상의 형에 따라 달라진다'는 설계를 사용했다. 하지만 모든 언어가 이런 설계를 선택하고 있지는 않다. ML에서는 정수 나눗셈엔 `x div y`, 부동 소수점 나눗셈에는 `x / y`를 사용했다. 또한 Python 3.0에서는 `x / y`으로 소수점 이하를 버리지 않는 나눗셈을 표현하고, 소수점 이하를 버리는 나눗셈은 `x // y`로 표현한다.



## 형의 다양한 전개

원래는 값의 종류를 저장하기 위해 사용한 개념이지만 이후 여러 곳에 응용되기 시작했다.



### 사용자 정의형과 객체 지향

먼저 '언어가 갖고 있는 기본적인 형을 조합해서 새로운 형을 만드는 기능'이 나왔다. C언어의 구조체가 대표적인 예다. 사용자 정의형이라고도 불린다.

다음으로 정수와 같은 데이터 뿐만 아니라 함수처럼 데이터를 처리하는 기능도 형으로 정리되었다. C++의 설계자는 이런 형에 클래스라는 이름을 붙였고, 이것이 제2의 객체 지향의 발명이다.



### 사양으로서의 형



#### 공개와 비공개

형은 사양이라는 개념이 등장했다. 구조체나 클래스를 구성하는 형을 최소한만 공개한다는 것이다. 형이 맞는지 틀린지는 컴파일러가 체크해준다. 그래서 외부와 작업하는 부분만 형으로 공개하고 상세 구현은 숨긴다는 발상이다. 이렇게 형의 공개 부분과 비공개 부분이 탄생했다. public, private이 이에 해당한다.



#### 인터페이스로 발전

형은 사양이라는 개념은 더욱 진화해서 구체적인 구현을 갖고 있지 않는 형(Java의 인터페이스)이 탄생했다. 또한 Java처럼 함수가 예외를 던질지 말지의 정보도 형에 포함하는 언어가 등장했다. 사양만 만족한다면 어떻게 구현하든 해당 구현 클래스의 생성자에 전달하는 것이 가능하다는 것이다.



### 총칭형, 제네릭스, 템플릿

다양한 형을 조합해서 만든 복잡한 형들이 사용되면서 일부만 변경하고 싶은데 전부 다시 정의해야하는 것이 비효율적이라는 생각이 생겼다. 그래서 '구성 요소의 형을 일부만 변경하는 형'인 총칭형이 탄생했다. '형이 인수를 갖고 형을 만드는 함수'가 생긴 것이다. C++의 템플릿, Java의 제네릭, Haskell의 형 생성자 등이 이런 구조다.



### 동적 형 결정

지금까지 형 구조에서 '변수명', '값이 저장된 메모리 위치', '해당 메모리의 내용은 어떤 값인지'는 언어 처리계가 한 세트로 갖고있었다. 이런 종류 정보를 값과 함께 갖고 있는 것을 동적 형 결정이라고 한다. 현재는 대부분의 스크립트 언어가 동적 형 결정을 채용하고 있다. 예를 들어 Python에선 변수형 선언이 필요 없고 같은 변수에 정수와 부동 소수점을 모두 넣을 수 있다.

```python
x = 1234
x = 3.1415
```



동적 형 결정 언어에서 형 선언이 필요 없는 이유는 메모리 상에서 동일한 형으로 취급되도록 설계되어 있기 때문이다. 예를 들어 Python에선 값이 정수든 부동 소수점이든 모두 PyObject형으로 취급되도록 헤더 부분이 모두 같은 형태로 되어있다. Python에서 변수 x는 C언어로 표현했을 때 `PyObject* x`이다. 따라서 값을 꺼내기 위해서 PyObject를 읽어야 하고 그 곳에 값의 형에 대한 정보가 있다.

이렇게 동적으로 형을 관리하면 정적 형 결정 언어에선 할 수 없었던 유연한 처리가 가능하다. 런타임 전까지 형을 정하지 않아도 되며 런타임에 형이 바뀌는 것도 가능하다. 하지만 이는 단점이기도 하다. 정적 형 언어에선 컴파일타임에 형이 정해지고 컴파일타임에 형의 정합성이 체크된다. 덕분에 일부 버그는 실행 전에 찾아낼 수 있다.



### 형 추론

컴파일타임에 형 체크는 하지만 형 선언은 하지 않기 위해 컴퓨터가 형을 추론하게 하는 접근이 있다. 형 추론은 원래 OCaml과 같은 ML계열의 언어가 잘 하는 분야였지만 최근에는 JVM 상에서 동작하는 언어인 Scala 등 형 추론을 장점으로 부각시키는 언어가 늘고 있다.



#### Haskell과 C언어 비교

Haskell에선 다음과 같이 1을 더하는 함수에서 1이 정수인 것으로부터 '인수와 반환값이 정수'라고 추론한다.

```haskell
let add_one = \x -> x + 1
```



반면 C언어에선 사람이 반환 타입을 int라고 선언해야 한다.

```c
int add_one(int x){
    return x + 1;
}
```



한편 Scala는 Haskell과는 다른 동작을 한다. Haskell에선 형을 정의하지 않으면 t -> t로 추론하지만, Scala에선 에러가 발생한다. 이와 같이 동일한 형 추론이더라도 언어에 따라 내용이 다르다.



## 정리

10이라는 수를 표현하기 위해 10개의 램프를 사용한 것이 가장 원시적인 방법이다. 인류는 가장 간단한 표현 방법이 무엇인지 고민했고, 자릿수를 발명했다. 그리고 효율을 추구하는 과정에서 2진법을 발명했다.

소수점이 붙은 수를 표현하기 위해 고정 소수점과 부동 소수점이 발명되었다. 현재는 부동 소수점을 많이 사용하지만 단점도 존재한다.

값을 정수로 해석해야 하는지 부동 소수점으로 해석해야하는지에 대한 정보를 컴퓨터가 관리하도록 하기 위해 형이 탄생했다. 초기엔 값의 종류만 기록했지만 이후 다양한 정보를 저장하게 되었다. 값에 대해 어떤 조작이 가능한지, 어떤 예외를 던지는 등의 정보를 형에 넣을 수 있게 되었다(클래스).